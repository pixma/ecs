                              1 ;--------------------------------------------------------
                              2 ; File Created by SDCC : free open source ANSI-C Compiler
                              3 ; Version 3.2.0 #8008 (Jul  6 2012) (MINGW32)
                              4 ; This file was generated Mon Sep 10 23:14:05 2012
                              5 ;--------------------------------------------------------
                              6 	.module main
                              7 	.optsdcc -mmcs51 --model-small
                              8 	
                              9 ;--------------------------------------------------------
                             10 ; Public variables in this module
                             11 ;--------------------------------------------------------
                             12 	.globl _cgram_Character_Slot
                             13 	.globl _main
                             14 	.globl _ecs_MainMenu
                             15 	.globl _CY
                             16 	.globl _AC
                             17 	.globl _F0
                             18 	.globl _RS1
                             19 	.globl _RS0
                             20 	.globl _OV
                             21 	.globl _F1
                             22 	.globl _P
                             23 	.globl _PS
                             24 	.globl _PT1
                             25 	.globl _PX1
                             26 	.globl _PT0
                             27 	.globl _PX0
                             28 	.globl _RD
                             29 	.globl _WR
                             30 	.globl _T1
                             31 	.globl _T0
                             32 	.globl _INT1
                             33 	.globl _INT0
                             34 	.globl _TXD
                             35 	.globl _RXD
                             36 	.globl _P3_7
                             37 	.globl _P3_6
                             38 	.globl _P3_5
                             39 	.globl _P3_4
                             40 	.globl _P3_3
                             41 	.globl _P3_2
                             42 	.globl _P3_1
                             43 	.globl _P3_0
                             44 	.globl _EA
                             45 	.globl _ES
                             46 	.globl _ET1
                             47 	.globl _EX1
                             48 	.globl _ET0
                             49 	.globl _EX0
                             50 	.globl _P2_7
                             51 	.globl _P2_6
                             52 	.globl _P2_5
                             53 	.globl _P2_4
                             54 	.globl _P2_3
                             55 	.globl _P2_2
                             56 	.globl _P2_1
                             57 	.globl _P2_0
                             58 	.globl _SM0
                             59 	.globl _SM1
                             60 	.globl _SM2
                             61 	.globl _REN
                             62 	.globl _TB8
                             63 	.globl _RB8
                             64 	.globl _TI
                             65 	.globl _RI
                             66 	.globl _P1_7
                             67 	.globl _P1_6
                             68 	.globl _P1_5
                             69 	.globl _P1_4
                             70 	.globl _P1_3
                             71 	.globl _P1_2
                             72 	.globl _P1_1
                             73 	.globl _P1_0
                             74 	.globl _TF1
                             75 	.globl _TR1
                             76 	.globl _TF0
                             77 	.globl _TR0
                             78 	.globl _IE1
                             79 	.globl _IT1
                             80 	.globl _IE0
                             81 	.globl _IT0
                             82 	.globl _P0_7
                             83 	.globl _P0_6
                             84 	.globl _P0_5
                             85 	.globl _P0_4
                             86 	.globl _P0_3
                             87 	.globl _P0_2
                             88 	.globl _P0_1
                             89 	.globl _P0_0
                             90 	.globl _B
                             91 	.globl _ACC
                             92 	.globl _PSW
                             93 	.globl _IP
                             94 	.globl _P3
                             95 	.globl _IE
                             96 	.globl _P2
                             97 	.globl _SBUF
                             98 	.globl _SCON
                             99 	.globl _P1
                            100 	.globl _TH1
                            101 	.globl _TH0
                            102 	.globl _TL1
                            103 	.globl _TL0
                            104 	.globl _TMOD
                            105 	.globl _TCON
                            106 	.globl _PCON
                            107 	.globl _DPH
                            108 	.globl _DPL
                            109 	.globl _SP
                            110 	.globl _P0
                            111 	.globl _getKeyHit_PARM_2
                            112 	.globl _RTC_setdate_PARM_3
                            113 	.globl _RTC_setdate_PARM_2
                            114 	.globl _RTC_settime_PARM_2
                            115 	.globl _eepromWriteTo_PARM_2
                            116 	.globl _ReadValueFrom_PARM_2
                            117 	.globl _setCursorLcd_PARM_2
                            118 	.globl _flag
                            119 	.globl _delay
                            120 	.globl _InitUartComm
                            121 	.globl _uartTransmit
                            122 	.globl _uartReceiver
                            123 	.globl _key_init
                            124 	.globl _get_key
                            125 	.globl _translateKeyCode
                            126 	.globl _lcdBegin
                            127 	.globl _writeLcd
                            128 	.globl _commandLcd
                            129 	.globl _displayCharLcd
                            130 	.globl _displayStringLcd
                            131 	.globl _DisplayIntegerLcd
                            132 	.globl _setCursorLcd
                            133 	.globl _IsBussy
                            134 	.globl _clearLcdScreen
                            135 	.globl _home
                            136 	.globl _CursorOff
                            137 	.globl _CursorOn
                            138 	.globl _BlinkOff
                            139 	.globl _BlinkOn
                            140 	.globl _MoveLeft
                            141 	.globl _MoveRight
                            142 	.globl _ReadFromLcd
                            143 	.globl _ReadValueFrom
                            144 	.globl _CharToInt
                            145 	.globl _SplashScreenWindow
                            146 	.globl _CustomCharData
                            147 	.globl _itwocStart
                            148 	.globl _itwocStop
                            149 	.globl _itwocAck
                            150 	.globl _itwocNoAck
                            151 	.globl _itwocClock
                            152 	.globl _itwocSendByte
                            153 	.globl _itwocGetByte
                            154 	.globl _itwocDelay
                            155 	.globl _itwocIsACK
                            156 	.globl _eepromStart
                            157 	.globl _eepromStop
                            158 	.globl _eepromAck
                            159 	.globl _eepromNoAck
                            160 	.globl _eepromClock
                            161 	.globl __nop_
                            162 	.globl _eepromWriteTo
                            163 	.globl _eepromReadFrom
                            164 	.globl _eepromSendByte
                            165 	.globl _eepromReadByte
                            166 	.globl _eepromReset
                            167 	.globl _showRtcDateDay
                            168 	.globl _showRtc
                            169 	.globl _startRtc
                            170 	.globl _rtcSendData
                            171 	.globl _rtcAck
                            172 	.globl _rtcStop
                            173 	.globl _rtcReceive
                            174 	.globl _rtcNoAck
                            175 	.globl _iicClock
                            176 	.globl _iicDelay
                            177 	.globl _RTC_get
                            178 	.globl _RTC_settime
                            179 	.globl _RTC_setdate
                            180 	.globl _RTC_sendToDisplay
                            181 	.globl _showScreenKeypad
                            182 	.globl _handleScreenKeypadLoop
                            183 	.globl _getKeyHit
                            184 	.globl _SettingActivity
                            185 	.globl _syncScreenActivity
                            186 	.globl _dataEntrySession
                            187 ;--------------------------------------------------------
                            188 ; special function registers
                            189 ;--------------------------------------------------------
                            190 	.area RSEG    (ABS,DATA)
   0000                     191 	.org 0x0000
                    0080    192 _P0	=	0x0080
                    0081    193 _SP	=	0x0081
                    0082    194 _DPL	=	0x0082
                    0083    195 _DPH	=	0x0083
                    0087    196 _PCON	=	0x0087
                    0088    197 _TCON	=	0x0088
                    0089    198 _TMOD	=	0x0089
                    008A    199 _TL0	=	0x008a
                    008B    200 _TL1	=	0x008b
                    008C    201 _TH0	=	0x008c
                    008D    202 _TH1	=	0x008d
                    0090    203 _P1	=	0x0090
                    0098    204 _SCON	=	0x0098
                    0099    205 _SBUF	=	0x0099
                    00A0    206 _P2	=	0x00a0
                    00A8    207 _IE	=	0x00a8
                    00B0    208 _P3	=	0x00b0
                    00B8    209 _IP	=	0x00b8
                    00D0    210 _PSW	=	0x00d0
                    00E0    211 _ACC	=	0x00e0
                    00F0    212 _B	=	0x00f0
                            213 ;--------------------------------------------------------
                            214 ; special function bits
                            215 ;--------------------------------------------------------
                            216 	.area RSEG    (ABS,DATA)
   0000                     217 	.org 0x0000
                    0080    218 _P0_0	=	0x0080
                    0081    219 _P0_1	=	0x0081
                    0082    220 _P0_2	=	0x0082
                    0083    221 _P0_3	=	0x0083
                    0084    222 _P0_4	=	0x0084
                    0085    223 _P0_5	=	0x0085
                    0086    224 _P0_6	=	0x0086
                    0087    225 _P0_7	=	0x0087
                    0088    226 _IT0	=	0x0088
                    0089    227 _IE0	=	0x0089
                    008A    228 _IT1	=	0x008a
                    008B    229 _IE1	=	0x008b
                    008C    230 _TR0	=	0x008c
                    008D    231 _TF0	=	0x008d
                    008E    232 _TR1	=	0x008e
                    008F    233 _TF1	=	0x008f
                    0090    234 _P1_0	=	0x0090
                    0091    235 _P1_1	=	0x0091
                    0092    236 _P1_2	=	0x0092
                    0093    237 _P1_3	=	0x0093
                    0094    238 _P1_4	=	0x0094
                    0095    239 _P1_5	=	0x0095
                    0096    240 _P1_6	=	0x0096
                    0097    241 _P1_7	=	0x0097
                    0098    242 _RI	=	0x0098
                    0099    243 _TI	=	0x0099
                    009A    244 _RB8	=	0x009a
                    009B    245 _TB8	=	0x009b
                    009C    246 _REN	=	0x009c
                    009D    247 _SM2	=	0x009d
                    009E    248 _SM1	=	0x009e
                    009F    249 _SM0	=	0x009f
                    00A0    250 _P2_0	=	0x00a0
                    00A1    251 _P2_1	=	0x00a1
                    00A2    252 _P2_2	=	0x00a2
                    00A3    253 _P2_3	=	0x00a3
                    00A4    254 _P2_4	=	0x00a4
                    00A5    255 _P2_5	=	0x00a5
                    00A6    256 _P2_6	=	0x00a6
                    00A7    257 _P2_7	=	0x00a7
                    00A8    258 _EX0	=	0x00a8
                    00A9    259 _ET0	=	0x00a9
                    00AA    260 _EX1	=	0x00aa
                    00AB    261 _ET1	=	0x00ab
                    00AC    262 _ES	=	0x00ac
                    00AF    263 _EA	=	0x00af
                    00B0    264 _P3_0	=	0x00b0
                    00B1    265 _P3_1	=	0x00b1
                    00B2    266 _P3_2	=	0x00b2
                    00B3    267 _P3_3	=	0x00b3
                    00B4    268 _P3_4	=	0x00b4
                    00B5    269 _P3_5	=	0x00b5
                    00B6    270 _P3_6	=	0x00b6
                    00B7    271 _P3_7	=	0x00b7
                    00B0    272 _RXD	=	0x00b0
                    00B1    273 _TXD	=	0x00b1
                    00B2    274 _INT0	=	0x00b2
                    00B3    275 _INT1	=	0x00b3
                    00B4    276 _T0	=	0x00b4
                    00B5    277 _T1	=	0x00b5
                    00B6    278 _WR	=	0x00b6
                    00B7    279 _RD	=	0x00b7
                    00B8    280 _PX0	=	0x00b8
                    00B9    281 _PT0	=	0x00b9
                    00BA    282 _PX1	=	0x00ba
                    00BB    283 _PT1	=	0x00bb
                    00BC    284 _PS	=	0x00bc
                    00D0    285 _P	=	0x00d0
                    00D1    286 _F1	=	0x00d1
                    00D2    287 _OV	=	0x00d2
                    00D3    288 _RS0	=	0x00d3
                    00D4    289 _RS1	=	0x00d4
                    00D5    290 _F0	=	0x00d5
                    00D6    291 _AC	=	0x00d6
                    00D7    292 _CY	=	0x00d7
                            293 ;--------------------------------------------------------
                            294 ; overlayable register banks
                            295 ;--------------------------------------------------------
                            296 	.area REG_BANK_0	(REL,OVR,DATA)
   0000                     297 	.ds 8
                            298 ;--------------------------------------------------------
                            299 ; internal ram data
                            300 ;--------------------------------------------------------
                            301 	.area DSEG    (DATA)
   0000                     302 _flag::
   0000                     303 	.ds 1
   0001                     304 _DisplayIntegerLcd_cInteger_1_55:
   0001                     305 	.ds 5
   0006                     306 _setCursorLcd_PARM_2:
   0006                     307 	.ds 2
   0008                     308 _ReadValueFrom_PARM_2:
   0008                     309 	.ds 2
   000A                     310 _eepromWriteTo_PARM_2:
   000A                     311 	.ds 1
   000B                     312 _showRtc_val_1_141:
   000B                     313 	.ds 8
   0013                     314 _RTC_settime_PARM_2:
   0013                     315 	.ds 1
   0014                     316 _RTC_setdate_PARM_2:
   0014                     317 	.ds 1
   0015                     318 _RTC_setdate_PARM_3:
   0015                     319 	.ds 1
   0016                     320 _handleScreenKeypadLoop_kFlag_1_161:
   0016                     321 	.ds 1
   0017                     322 _handleScreenKeypadLoop_breakpoint_1_161:
   0017                     323 	.ds 1
   0018                     324 _handleScreenKeypadLoop_hitCount_1_161:
   0018                     325 	.ds 2
   001A                     326 _getKeyHit_PARM_2:
   001A                     327 	.ds 2
   001C                     328 _SettingActivity_cZVal_1_184:
   001C                     329 	.ds 1
   001D                     330 _SettingActivity_cLVal_1_184:
   001D                     331 	.ds 1
   001E                     332 _SettingActivity_time_1_184:
   001E                     333 	.ds 4
   0022                     334 _SettingActivity_date_1_184:
   0022                     335 	.ds 6
   0028                     336 _SettingActivity_ni_1_184:
   0028                     337 	.ds 2
                            338 ;--------------------------------------------------------
                            339 ; overlayable items in internal ram 
                            340 ;--------------------------------------------------------
                            341 	.area	OSEG    (OVR,DATA)
                            342 	.area	OSEG    (OVR,DATA)
                            343 	.area	OSEG    (OVR,DATA)
                            344 	.area	OSEG    (OVR,DATA)
                            345 	.area	OSEG    (OVR,DATA)
                            346 	.area	OSEG    (OVR,DATA)
                            347 	.area	OSEG    (OVR,DATA)
                            348 ;--------------------------------------------------------
                            349 ; Stack segment in internal ram 
                            350 ;--------------------------------------------------------
                            351 	.area	SSEG	(DATA)
   0000                     352 __start__stack:
   0000                     353 	.ds	1
                            354 
                            355 ;--------------------------------------------------------
                            356 ; indirectly addressable internal ram data
                            357 ;--------------------------------------------------------
                            358 	.area ISEG    (DATA)
                            359 ;--------------------------------------------------------
                            360 ; absolute internal ram data
                            361 ;--------------------------------------------------------
                            362 	.area IABS    (ABS,DATA)
                            363 	.area IABS    (ABS,DATA)
                            364 ;--------------------------------------------------------
                            365 ; bit data
                            366 ;--------------------------------------------------------
                            367 	.area BSEG    (BIT)
   0000                     368 _eepromSendByte_sloc0_1_0:
   0000                     369 	.ds 1
                            370 ;--------------------------------------------------------
                            371 ; paged external ram data
                            372 ;--------------------------------------------------------
                            373 	.area PSEG    (PAG,XDATA)
                            374 ;--------------------------------------------------------
                            375 ; external ram data
                            376 ;--------------------------------------------------------
                            377 	.area XSEG    (XDATA)
                            378 ;--------------------------------------------------------
                            379 ; absolute external ram data
                            380 ;--------------------------------------------------------
                            381 	.area XABS    (ABS,XDATA)
                            382 ;--------------------------------------------------------
                            383 ; external initialized ram data
                            384 ;--------------------------------------------------------
                            385 	.area XISEG   (XDATA)
                            386 	.area HOME    (CODE)
                            387 	.area GSINIT0 (CODE)
                            388 	.area GSINIT1 (CODE)
                            389 	.area GSINIT2 (CODE)
                            390 	.area GSINIT3 (CODE)
                            391 	.area GSINIT4 (CODE)
                            392 	.area GSINIT5 (CODE)
                            393 	.area GSINIT  (CODE)
                            394 	.area GSFINAL (CODE)
                            395 	.area CSEG    (CODE)
                            396 ;--------------------------------------------------------
                            397 ; interrupt vector 
                            398 ;--------------------------------------------------------
                            399 	.area HOME    (CODE)
   0000                     400 __interrupt_vect:
   0000 02s00r00            401 	ljmp	__sdcc_gsinit_startup
                            402 ;--------------------------------------------------------
                            403 ; global & static initialisations
                            404 ;--------------------------------------------------------
                            405 	.area HOME    (CODE)
                            406 	.area GSINIT  (CODE)
                            407 	.area GSFINAL (CODE)
                            408 	.area GSINIT  (CODE)
                            409 	.globl __sdcc_gsinit_startup
                            410 	.globl __sdcc_program_startup
                            411 	.globl __start__stack
                            412 	.globl __mcs51_genXINIT
                            413 	.globl __mcs51_genXRAMCLEAR
                            414 	.globl __mcs51_genRAMCLEAR
                            415 	.area GSFINAL (CODE)
   0000 02s00r03            416 	ljmp	__sdcc_program_startup
                            417 ;--------------------------------------------------------
                            418 ; Home
                            419 ;--------------------------------------------------------
                            420 	.area HOME    (CODE)
                            421 	.area HOME    (CODE)
   0003                     422 __sdcc_program_startup:
   0003 12s15r90            423 	lcall	_main
                            424 ;	return from main will lock up
   0006 80 FE               425 	sjmp .
                            426 ;--------------------------------------------------------
                            427 ; code
                            428 ;--------------------------------------------------------
                            429 	.area CSEG    (CODE)
                            430 ;------------------------------------------------------------
                            431 ;Allocation info for local variables in function 'delay'
                            432 ;------------------------------------------------------------
                            433 ;nCount                    Allocated to registers r6 r7 
                            434 ;i                         Allocated to registers r2 r3 
                            435 ;j                         Allocated to registers r0 r1 
                            436 ;k                         Allocated to registers r4 r5 
                            437 ;------------------------------------------------------------
                            438 ;	libdelay.c:7: void delay( int nCount ){
                            439 ;	-----------------------------------------
                            440 ;	 function delay
                            441 ;	-----------------------------------------
   0000                     442 _delay:
                    0007    443 	ar7 = 0x07
                    0006    444 	ar6 = 0x06
                    0005    445 	ar5 = 0x05
                    0004    446 	ar4 = 0x04
                    0003    447 	ar3 = 0x03
                    0002    448 	ar2 = 0x02
                    0001    449 	ar1 = 0x01
                    0000    450 	ar0 = 0x00
   0000 AE 82               451 	mov	r6,dpl
   0002 AF 83               452 	mov	r7,dph
                            453 ;	libdelay.c:9: for ( k=0; k<nCount;k++)
   0004 7C 00               454 	mov	r4,#0x00
   0006 7D 00               455 	mov	r5,#0x00
   0008                     456 00108$:
   0008 C3                  457 	clr	c
   0009 EC                  458 	mov	a,r4
   000A 9E                  459 	subb	a,r6
   000B ED                  460 	mov	a,r5
   000C 64 80               461 	xrl	a,#0x80
   000E 8F F0               462 	mov	b,r7
   0010 63 F0 80            463 	xrl	b,#0x80
   0013 95 F0               464 	subb	a,b
   0015 50 2A               465 	jnc	00112$
                            466 ;	libdelay.c:10: for( i = 0; i < 50 ; i++ ){
   0017 7A 00               467 	mov	r2,#0x00
   0019 7B 00               468 	mov	r3,#0x00
   001B                     469 00104$:
   001B C3                  470 	clr	c
   001C EA                  471 	mov	a,r2
   001D 94 32               472 	subb	a,#0x32
   001F EB                  473 	mov	a,r3
   0020 64 80               474 	xrl	a,#0x80
   0022 94 80               475 	subb	a,#0x80
   0024 50 14               476 	jnc	00110$
                            477 ;	libdelay.c:11: for ( j = 0; j< 5 ; j++);
   0026 78 05               478 	mov	r0,#0x05
   0028 79 00               479 	mov	r1,#0x00
   002A                     480 00103$:
   002A 18                  481 	dec	r0
   002B B8 FF 01            482 	cjne	r0,#0xFF,00131$
   002E 19                  483 	dec	r1
   002F                     484 00131$:
   002F E8                  485 	mov	a,r0
   0030 49                  486 	orl	a,r1
   0031 70 F7               487 	jnz	00103$
                            488 ;	libdelay.c:10: for( i = 0; i < 50 ; i++ ){
   0033 0A                  489 	inc	r2
   0034 BA 00 E4            490 	cjne	r2,#0x00,00104$
   0037 0B                  491 	inc	r3
   0038 80 E1               492 	sjmp	00104$
   003A                     493 00110$:
                            494 ;	libdelay.c:9: for ( k=0; k<nCount;k++)
   003A 0C                  495 	inc	r4
   003B BC 00 CA            496 	cjne	r4,#0x00,00108$
   003E 0D                  497 	inc	r5
   003F 80 C7               498 	sjmp	00108$
   0041                     499 00112$:
   0041 22                  500 	ret
                            501 ;------------------------------------------------------------
                            502 ;Allocation info for local variables in function 'InitUartComm'
                            503 ;------------------------------------------------------------
                            504 ;	libuartcomm.c:9: void InitUartComm( void ){
                            505 ;	-----------------------------------------
                            506 ;	 function InitUartComm
                            507 ;	-----------------------------------------
   0042                     508 _InitUartComm:
                            509 ;	libuartcomm.c:11: SCON = 0x50;		//to start the standard uart communication with mode 1 and receiver enabled.
   0042 75 98 50            510 	mov	_SCON,#0x50
                            511 ;	libuartcomm.c:12: TMOD = 0x20;		//configure the timer 1 to auto reload mode.
   0045 75 89 20            512 	mov	_TMOD,#0x20
                            513 ;	libuartcomm.c:13: TH1=THVALUE;
   0048 75 8D FD            514 	mov	_TH1,#0xFD
                            515 ;	libuartcomm.c:14: TL1=THVALUE;	//to set to 9600 baud rate.
   004B 75 8B FD            516 	mov	_TL1,#0xFD
                            517 ;	libuartcomm.c:15: TR1= 1;				//to start the baud clock.
   004E D2 8E               518 	setb	_TR1
   0050 22                  519 	ret
                            520 ;------------------------------------------------------------
                            521 ;Allocation info for local variables in function 'uartTransmit'
                            522 ;------------------------------------------------------------
                            523 ;c                         Allocated to registers 
                            524 ;------------------------------------------------------------
                            525 ;	libuartcomm.c:17: void uartTransmit( char c){
                            526 ;	-----------------------------------------
                            527 ;	 function uartTransmit
                            528 ;	-----------------------------------------
   0051                     529 _uartTransmit:
   0051 85 82 99            530 	mov	_SBUF,dpl
                            531 ;	libuartcomm.c:21: while( TI == 0){}
   0054                     532 00101$:
                            533 ;	libuartcomm.c:22: TI = 0;				//Transmitt interrupt will be zero as long as tranmission of data going on, when done it sets to 1. so reset to 0 for annother transmission session.	
   0054 10 99 02            534 	jbc	_TI,00110$
   0057 80 FB               535 	sjmp	00101$
   0059                     536 00110$:
   0059 22                  537 	ret
                            538 ;------------------------------------------------------------
                            539 ;Allocation info for local variables in function 'uartReceiver'
                            540 ;------------------------------------------------------------
                            541 ;	libuartcomm.c:24: char uartReceiver( void ){
                            542 ;	-----------------------------------------
                            543 ;	 function uartReceiver
                            544 ;	-----------------------------------------
   005A                     545 _uartReceiver:
                            546 ;	libuartcomm.c:26: while( RI == 0){}
   005A                     547 00101$:
                            548 ;	libuartcomm.c:27: RI = 0;
   005A 10 98 02            549 	jbc	_RI,00110$
   005D 80 FB               550 	sjmp	00101$
   005F                     551 00110$:
                            552 ;	libuartcomm.c:28: return SBUF;
   005F 85 99 82            553 	mov	dpl,_SBUF
   0062 22                  554 	ret
                            555 ;------------------------------------------------------------
                            556 ;Allocation info for local variables in function 'key_init'
                            557 ;------------------------------------------------------------
                            558 ;	libkeypad.c:4: void key_init(){
                            559 ;	-----------------------------------------
                            560 ;	 function key_init
                            561 ;	-----------------------------------------
   0063                     562 _key_init:
                            563 ;	libkeypad.c:5: keyport &=0x0F; //make Rows as o/p and cols are i/p
   0063 53 B0 0F            564 	anl	_P3,#0x0F
   0066 22                  565 	ret
                            566 ;------------------------------------------------------------
                            567 ;Allocation info for local variables in function 'get_key'
                            568 ;------------------------------------------------------------
                            569 ;i                         Allocated to registers r5 
                            570 ;k                         Allocated to registers r7 
                            571 ;key                       Allocated to registers r3 
                            572 ;------------------------------------------------------------
                            573 ;	libkeypad.c:8: unsigned char get_key(){
                            574 ;	-----------------------------------------
                            575 ;	 function get_key
                            576 ;	-----------------------------------------
   0067                     577 _get_key:
                            578 ;	libkeypad.c:10: k=1;
   0067 7F 01               579 	mov	r7,#0x01
                            580 ;	libkeypad.c:11: for(i=0;i<4;i++){               //loop for 4 rows
   0069 7E 01               581 	mov	r6,#0x01
   006B 7D 00               582 	mov	r5,#0x00
   006D                     583 00121$:
   006D C3                  584 	clr	c
   006E ED                  585 	mov	a,r5
   006F 64 80               586 	xrl	a,#0x80
   0071 94 84               587 	subb	a,#0x84
   0073 50 4E               588 	jnc	00124$
                            589 ;	libkeypad.c:12: keyport &=~(0x80>>i);   //to make rows low 1 by 1
   0075 8D F0               590 	mov	b,r5
   0077 05 F0               591 	inc	b
   0079 74 80               592 	mov	a,#0x80
   007B 80 02               593 	sjmp	00157$
   007D                     594 00156$:
   007D C3                  595 	clr	c
   007E 13                  596 	rrc	a
   007F                     597 00157$:
   007F D5 F0 FB            598 	djnz	b,00156$
   0082 FC                  599 	mov	r4,a
   0083 F4                  600 	cpl	a
   0084 FB                  601 	mov	r3,a
   0085 52 B0               602 	anl	_P3,a
                            603 ;	libkeypad.c:13: if(!col1){      //check if key1 is pressed
   0087 20 B3 08            604 	jb	_P3_3,00105$
                            605 ;	libkeypad.c:14: key = k+0;      //set key number
   008A 8F 03               606 	mov	ar3,r7
                            607 ;	libkeypad.c:15: while(!col1);   //wait for release
   008C                     608 00101$:
   008C 30 B3 FD            609 	jnb	_P3_3,00101$
                            610 ;	libkeypad.c:16: return key;     //return key number
   008F 8B 82               611 	mov	dpl,r3
   0091 22                  612 	ret
   0092                     613 00105$:
                            614 ;	libkeypad.c:18: if(!col2){      //check if key2 is pressed
   0092 20 B2 09            615 	jb	_P3_2,00110$
                            616 ;	libkeypad.c:19: key = k+1;      //set key number
   0095 EF                  617 	mov	a,r7
   0096 04                  618 	inc	a
   0097 FB                  619 	mov	r3,a
                            620 ;	libkeypad.c:20: while(!col2);   //wait for release
   0098                     621 00106$:
   0098 30 B2 FD            622 	jnb	_P3_2,00106$
                            623 ;	libkeypad.c:21: return key;     //return key number
   009B 8B 82               624 	mov	dpl,r3
   009D 22                  625 	ret
   009E                     626 00110$:
                            627 ;	libkeypad.c:23: if(!col3){      //check if key3 is pressed
   009E 20 B1 0A            628 	jb	_P3_1,00115$
                            629 ;	libkeypad.c:24: key = k+2;      //set key number
   00A1 74 02               630 	mov	a,#0x02
   00A3 2F                  631 	add	a,r7
   00A4 FB                  632 	mov	r3,a
                            633 ;	libkeypad.c:25: while(!col3);   //wait for release
   00A5                     634 00111$:
   00A5 30 B1 FD            635 	jnb	_P3_1,00111$
                            636 ;	libkeypad.c:26: return key;     //return key number
   00A8 8B 82               637 	mov	dpl,r3
   00AA 22                  638 	ret
   00AB                     639 00115$:
                            640 ;	libkeypad.c:28: if(!col4){      //check if key4 is pressed
   00AB 20 B0 0A            641 	jb	_P3_0,00120$
                            642 ;	libkeypad.c:29: key = k+3;      //set key number
   00AE 74 03               643 	mov	a,#0x03
   00B0 2F                  644 	add	a,r7
   00B1 FB                  645 	mov	r3,a
                            646 ;	libkeypad.c:30: while(!col4);   //wait for release
   00B2                     647 00116$:
   00B2 30 B0 FD            648 	jnb	_P3_0,00116$
                            649 ;	libkeypad.c:31: return key;     //return key number
   00B5 8B 82               650 	mov	dpl,r3
   00B7 22                  651 	ret
   00B8                     652 00120$:
                            653 ;	libkeypad.c:33: k+=4;                   //next row key number
   00B8 EE                  654 	mov	a,r6
   00B9 24 04               655 	add	a,#0x04
   00BB FE                  656 	mov	r6,a
   00BC FF                  657 	mov	r7,a
                            658 ;	libkeypad.c:34: keyport |= 0x80>>i;     //make the row high again
   00BD EC                  659 	mov	a,r4
   00BE 42 B0               660 	orl	_P3,a
                            661 ;	libkeypad.c:11: for(i=0;i<4;i++){               //loop for 4 rows
   00C0 0D                  662 	inc	r5
   00C1 80 AA               663 	sjmp	00121$
   00C3                     664 00124$:
                            665 ;	libkeypad.c:36: return FALSE;                   //return false if no key pressed
   00C3 75 82 00            666 	mov	dpl,#0x00
   00C6 22                  667 	ret
                            668 ;------------------------------------------------------------
                            669 ;Allocation info for local variables in function 'translateKeyCode'
                            670 ;------------------------------------------------------------
                            671 ;keyval                    Allocated to registers r7 
                            672 ;------------------------------------------------------------
                            673 ;	libkeypad.c:39: char translateKeyCode( unsigned char keyval)
                            674 ;	-----------------------------------------
                            675 ;	 function translateKeyCode
                            676 ;	-----------------------------------------
   00C7                     677 _translateKeyCode:
   00C7 AF 82               678 	mov	r7,dpl
                            679 ;	libkeypad.c:41: if(keyval<10)
   00C9 BF 0A 00            680 	cjne	r7,#0x0A,00116$
   00CC                     681 00116$:
   00CC E4                  682 	clr	a
   00CD 33                  683 	rlc	a
   00CE FE                  684 	mov	r6,a
   00CF 60 08               685 	jz	00106$
                            686 ;	libkeypad.c:42: return keyval+'0'; 
   00D1 8F 05               687 	mov	ar5,r7
   00D3 74 30               688 	mov	a,#0x30
   00D5 2D                  689 	add	a,r5
   00D6 F5 82               690 	mov	dpl,a
   00D8 22                  691 	ret
   00D9                     692 00106$:
                            693 ;	libkeypad.c:43: else if(keyval>=10 && keyval <= 16)
   00D9 EE                  694 	mov	a,r6
   00DA 70 0B               695 	jnz	00102$
   00DC EF                  696 	mov	a,r7
   00DD 24 EF               697 	add	a,#0xff - 0x10
   00DF 40 06               698 	jc	00102$
                            699 ;	libkeypad.c:44: return keyval - 10 + 'A';				
   00E1 74 37               700 	mov	a,#0x37
   00E3 2F                  701 	add	a,r7
   00E4 F5 82               702 	mov	dpl,a
   00E6 22                  703 	ret
   00E7                     704 00102$:
                            705 ;	libkeypad.c:46: return '?';
   00E7 75 82 3F            706 	mov	dpl,#0x3F
   00EA 22                  707 	ret
                            708 ;------------------------------------------------------------
                            709 ;Allocation info for local variables in function 'lcdBegin'
                            710 ;------------------------------------------------------------
                            711 ;	liblcd204.c:8: void lcdBegin( void ){			//Initializaes the LCD with neccessarry environment.
                            712 ;	-----------------------------------------
                            713 ;	 function lcdBegin
                            714 ;	-----------------------------------------
   00EB                     715 _lcdBegin:
                            716 ;	liblcd204.c:10: commandLcd( 0x01 );
   00EB 75 82 01            717 	mov	dpl,#0x01
   00EE 12s01r5B            718 	lcall	_commandLcd
                            719 ;	liblcd204.c:11: commandLcd( 0x02 );		//go to home, DDRAM content changeless.	
   00F1 75 82 02            720 	mov	dpl,#0x02
   00F4 12s01r5B            721 	lcall	_commandLcd
                            722 ;	liblcd204.c:13: commandLcd( 0x28 );		//for 5x7 pixel and 4 bit data line configuration.	
   00F7 75 82 28            723 	mov	dpl,#0x28
   00FA 12s01r5B            724 	lcall	_commandLcd
                            725 ;	liblcd204.c:15: commandLcd( 0x06 );		//entry mode increment mode, move right after displaying one character.
   00FD 75 82 06            726 	mov	dpl,#0x06
   0100 12s01r5B            727 	lcall	_commandLcd
                            728 ;	liblcd204.c:17: commandLcd( 0x0c );		// Display On, cursor off, and blink Off.
   0103 75 82 0C            729 	mov	dpl,#0x0C
   0106 12s01r5B            730 	lcall	_commandLcd
                            731 ;	liblcd204.c:19: clearLcdScreen();	
   0109 12s02r68            732 	lcall	_clearLcdScreen
                            733 ;	liblcd204.c:21: CursorOn();
   010C 12s02r7D            734 	lcall	_CursorOn
                            735 ;	liblcd204.c:23: setCursorLcd( 0, 0 );
   010F E4                  736 	clr	a
   0110 F5*06               737 	mov	_setCursorLcd_PARM_2,a
   0112 F5*07               738 	mov	(_setCursorLcd_PARM_2 + 1),a
   0114 F5 82               739 	mov	dpl,a
   0116 F5 83               740 	mov	dph,a
   0118 02s02r10            741 	ljmp	_setCursorLcd
                            742 ;------------------------------------------------------------
                            743 ;Allocation info for local variables in function 'writeLcd'
                            744 ;------------------------------------------------------------
                            745 ;cDat                      Allocated to registers r7 
                            746 ;------------------------------------------------------------
                            747 ;	liblcd204.c:27: void writeLcd( char cDat){
                            748 ;	-----------------------------------------
                            749 ;	 function writeLcd
                            750 ;	-----------------------------------------
   011B                     751 _writeLcd:
   011B AF 82               752 	mov	r7,dpl
                            753 ;	liblcd204.c:30: LCD_PORT=( cDat&0xf0 );				//1st Cycle.
   011D 74 F0               754 	mov	a,#0xF0
   011F 5F                  755 	anl	a,r7
   0120 F5 A0               756 	mov	_P2,a
                            757 ;	liblcd204.c:32: RW_PIN=0;
   0122 C2 A2               758 	clr	_P2_2
                            759 ;	liblcd204.c:33: if( flag == 0 )	RS_PIN = 1;
   0124 E5*00               760 	mov	a,_flag
   0126 70 04               761 	jnz	00104$
   0128 D2 A1               762 	setb	_P2_1
   012A 80 07               763 	sjmp	00105$
   012C                     764 00104$:
                            765 ;	liblcd204.c:34: else if( flag == 1 ) RS_PIN = 0;
   012C 74 01               766 	mov	a,#0x01
   012E B5*00 02            767 	cjne	a,_flag,00105$
   0131 C2 A1               768 	clr	_P2_1
   0133                     769 00105$:
                            770 ;	liblcd204.c:35: EN_PIN=1;
   0133 D2 A3               771 	setb	_P2_3
                            772 ;	liblcd204.c:36: EN_PIN=0;
   0135 C2 A3               773 	clr	_P2_3
                            774 ;	liblcd204.c:39: LCD_PORT= ( (cDat&0x0f)<<4 );		// 2nd Cycle.
   0137 53 07 0F            775 	anl	ar7,#0x0F
   013A EF                  776 	mov	a,r7
   013B C4                  777 	swap	a
   013C 54 F0               778 	anl	a,#0xF0
   013E F5 A0               779 	mov	_P2,a
                            780 ;	liblcd204.c:40: RW_PIN=0;
   0140 C2 A2               781 	clr	_P2_2
                            782 ;	liblcd204.c:41: if( flag == 0 )	RS_PIN = 1;
   0142 E5*00               783 	mov	a,_flag
   0144 70 04               784 	jnz	00109$
   0146 D2 A1               785 	setb	_P2_1
   0148 80 07               786 	sjmp	00110$
   014A                     787 00109$:
                            788 ;	liblcd204.c:42: else if( flag == 1 ) RS_PIN = 0;
   014A 74 01               789 	mov	a,#0x01
   014C B5*00 02            790 	cjne	a,_flag,00110$
   014F C2 A1               791 	clr	_P2_1
   0151                     792 00110$:
                            793 ;	liblcd204.c:43: EN_PIN=1;
   0151 D2 A3               794 	setb	_P2_3
                            795 ;	liblcd204.c:44: EN_PIN=0;
   0153 C2 A3               796 	clr	_P2_3
                            797 ;	liblcd204.c:45: delay( 1 );
   0155 90 00 01            798 	mov	dptr,#0x0001
   0158 02s00r00            799 	ljmp	_delay
                            800 ;------------------------------------------------------------
                            801 ;Allocation info for local variables in function 'commandLcd'
                            802 ;------------------------------------------------------------
                            803 ;cmd                       Allocated to registers 
                            804 ;------------------------------------------------------------
                            805 ;	liblcd204.c:48: void commandLcd( char cmd){	
                            806 ;	-----------------------------------------
                            807 ;	 function commandLcd
                            808 ;	-----------------------------------------
   015B                     809 _commandLcd:
                            810 ;	liblcd204.c:49: flag=1;
   015B 75*00 01            811 	mov	_flag,#0x01
                            812 ;	liblcd204.c:50: RS_PIN = 0;
   015E C2 A1               813 	clr	_P2_1
                            814 ;	liblcd204.c:51: writeLcd( cmd );
   0160 02s01r1B            815 	ljmp	_writeLcd
                            816 ;------------------------------------------------------------
                            817 ;Allocation info for local variables in function 'displayCharLcd'
                            818 ;------------------------------------------------------------
                            819 ;ch                        Allocated to registers 
                            820 ;------------------------------------------------------------
                            821 ;	liblcd204.c:55: void displayCharLcd( char ch ){
                            822 ;	-----------------------------------------
                            823 ;	 function displayCharLcd
                            824 ;	-----------------------------------------
   0163                     825 _displayCharLcd:
                            826 ;	liblcd204.c:56: flag=0;
   0163 75*00 00            827 	mov	_flag,#0x00
                            828 ;	liblcd204.c:57: RS_PIN = 1;
   0166 D2 A1               829 	setb	_P2_1
                            830 ;	liblcd204.c:58: writeLcd( ch );
   0168 02s01r1B            831 	ljmp	_writeLcd
                            832 ;------------------------------------------------------------
                            833 ;Allocation info for local variables in function 'displayStringLcd'
                            834 ;------------------------------------------------------------
                            835 ;str                       Allocated to registers 
                            836 ;------------------------------------------------------------
                            837 ;	liblcd204.c:62: void displayStringLcd( char *str ){
                            838 ;	-----------------------------------------
                            839 ;	 function displayStringLcd
                            840 ;	-----------------------------------------
   016B                     841 _displayStringLcd:
   016B AD 82               842 	mov	r5,dpl
   016D AE 83               843 	mov	r6,dph
   016F AF F0               844 	mov	r7,b
                            845 ;	liblcd204.c:64: while( *str )
   0171                     846 00101$:
   0171 8D 82               847 	mov	dpl,r5
   0173 8E 83               848 	mov	dph,r6
   0175 8F F0               849 	mov	b,r7
   0177 12s00r00            850 	lcall	__gptrget
   017A FC                  851 	mov	r4,a
   017B 60 18               852 	jz	00104$
                            853 ;	liblcd204.c:65: displayCharLcd( *str++);
   017D 8C 82               854 	mov	dpl,r4
   017F 0D                  855 	inc	r5
   0180 BD 00 01            856 	cjne	r5,#0x00,00112$
   0183 0E                  857 	inc	r6
   0184                     858 00112$:
   0184 C0 07               859 	push	ar7
   0186 C0 06               860 	push	ar6
   0188 C0 05               861 	push	ar5
   018A 12s01r63            862 	lcall	_displayCharLcd
   018D D0 05               863 	pop	ar5
   018F D0 06               864 	pop	ar6
   0191 D0 07               865 	pop	ar7
   0193 80 DC               866 	sjmp	00101$
   0195                     867 00104$:
   0195 22                  868 	ret
                            869 ;------------------------------------------------------------
                            870 ;Allocation info for local variables in function 'DisplayIntegerLcd'
                            871 ;------------------------------------------------------------
                            872 ;integer                   Allocated to registers r6 r7 
                            873 ;cChar                     Allocated to registers 
                            874 ;cInteger                  Allocated with name '_DisplayIntegerLcd_cInteger_1_55'
                            875 ;------------------------------------------------------------
                            876 ;	liblcd204.c:69: void DisplayIntegerLcd( unsigned int integer){
                            877 ;	-----------------------------------------
                            878 ;	 function DisplayIntegerLcd
                            879 ;	-----------------------------------------
   0196                     880 _DisplayIntegerLcd:
   0196 AE 82               881 	mov	r6,dpl
   0198 AF 83               882 	mov	r7,dph
                            883 ;	liblcd204.c:72: char cInteger[5] = { 0 };
   019A 75*01 00            884 	mov	_DisplayIntegerLcd_cInteger_1_55,#0x00
   019D 75*02 00            885 	mov	(_DisplayIntegerLcd_cInteger_1_55 + 0x0001),#0x00
                            886 ;	liblcd204.c:74: if( integer == 0){
   01A0 E4                  887 	clr	a
   01A1 F5*03               888 	mov	(_DisplayIntegerLcd_cInteger_1_55 + 0x0002),a
   01A3 F5*04               889 	mov	(_DisplayIntegerLcd_cInteger_1_55 + 0x0003),a
   01A5 F5*05               890 	mov	(_DisplayIntegerLcd_cInteger_1_55 + 0x0004),a
   01A7 EE                  891 	mov	a,r6
   01A8 4F                  892 	orl	a,r7
   01A9 70 06               893 	jnz	00115$
                            894 ;	liblcd204.c:75: displayCharLcd( '0' );
   01AB 75 82 30            895 	mov	dpl,#0x30
                            896 ;	liblcd204.c:76: return;
                            897 ;	liblcd204.c:79: while( integer > 0){
   01AE 02s01r63            898 	ljmp	_displayCharLcd
   01B1                     899 00115$:
   01B1 7D 00               900 	mov	r5,#0x00
   01B3                     901 00101$:
   01B3 EE                  902 	mov	a,r6
   01B4 4F                  903 	orl	a,r7
   01B5 60 41               904 	jz	00103$
                            905 ;	liblcd204.c:80: cInteger[cChar++]=( integer%10) + 48;
   01B7 8D 04               906 	mov	ar4,r5
   01B9 0D                  907 	inc	r5
   01BA EC                  908 	mov	a,r4
   01BB 24r01               909 	add	a,#_DisplayIntegerLcd_cInteger_1_55
   01BD F9                  910 	mov	r1,a
   01BE 75*00 0A            911 	mov	__moduint_PARM_2,#0x0A
   01C1 75*01 00            912 	mov	(__moduint_PARM_2 + 1),#0x00
   01C4 8E 82               913 	mov	dpl,r6
   01C6 8F 83               914 	mov	dph,r7
   01C8 C0 07               915 	push	ar7
   01CA C0 06               916 	push	ar6
   01CC C0 05               917 	push	ar5
   01CE C0 01               918 	push	ar1
   01D0 12s00r00            919 	lcall	__moduint
   01D3 AB 82               920 	mov	r3,dpl
   01D5 D0 01               921 	pop	ar1
   01D7 D0 05               922 	pop	ar5
   01D9 D0 06               923 	pop	ar6
   01DB D0 07               924 	pop	ar7
   01DD 74 30               925 	mov	a,#0x30
   01DF 2B                  926 	add	a,r3
   01E0 F7                  927 	mov	@r1,a
                            928 ;	liblcd204.c:81: integer /= 10;
   01E1 75*00 0A            929 	mov	__divuint_PARM_2,#0x0A
   01E4 75*01 00            930 	mov	(__divuint_PARM_2 + 1),#0x00
   01E7 8E 82               931 	mov	dpl,r6
   01E9 8F 83               932 	mov	dph,r7
   01EB C0 05               933 	push	ar5
   01ED 12s00r00            934 	lcall	__divuint
   01F0 AE 82               935 	mov	r6,dpl
   01F2 AF 83               936 	mov	r7,dph
   01F4 D0 05               937 	pop	ar5
   01F6 80 BB               938 	sjmp	00101$
   01F8                     939 00103$:
                            940 ;	liblcd204.c:83: for( --cChar; cChar>= 0 ; cChar--){
   01F8 ED                  941 	mov	a,r5
   01F9 14                  942 	dec	a
   01FA FF                  943 	mov	r7,a
   01FB                     944 00107$:
   01FB EF                  945 	mov	a,r7
   01FC 20 E7 10            946 	jb	acc.7,00111$
                            947 ;	liblcd204.c:84: displayCharLcd( cInteger[cChar] );
   01FF EF                  948 	mov	a,r7
   0200 24r01               949 	add	a,#_DisplayIntegerLcd_cInteger_1_55
   0202 F9                  950 	mov	r1,a
   0203 87 82               951 	mov	dpl,@r1
   0205 C0 07               952 	push	ar7
   0207 12s01r63            953 	lcall	_displayCharLcd
   020A D0 07               954 	pop	ar7
                            955 ;	liblcd204.c:83: for( --cChar; cChar>= 0 ; cChar--){
   020C 1F                  956 	dec	r7
   020D 80 EC               957 	sjmp	00107$
   020F                     958 00111$:
   020F 22                  959 	ret
                            960 ;------------------------------------------------------------
                            961 ;Allocation info for local variables in function 'setCursorLcd'
                            962 ;------------------------------------------------------------
                            963 ;col                       Allocated with name '_setCursorLcd_PARM_2'
                            964 ;row                       Allocated to registers r6 r7 
                            965 ;------------------------------------------------------------
                            966 ;	liblcd204.c:90: void setCursorLcd( unsigned int row, unsigned int col ){//set Cursor of LCD to specified Position.
                            967 ;	-----------------------------------------
                            968 ;	 function setCursorLcd
                            969 ;	-----------------------------------------
   0210                     970 _setCursorLcd:
   0210 AE 82               971 	mov	r6,dpl
   0212 AF 83               972 	mov	r7,dph
                            973 ;	liblcd204.c:92: if( row == 0 ){
   0214 EE                  974 	mov	a,r6
   0215 4F                  975 	orl	a,r7
   0216 70 0A               976 	jnz	00111$
                            977 ;	liblcd204.c:93: commandLcd( 0x80 + col );		
   0218 AD*06               978 	mov	r5,_setCursorLcd_PARM_2
   021A 74 80               979 	mov	a,#0x80
   021C 2D                  980 	add	a,r5
   021D F5 82               981 	mov	dpl,a
                            982 ;	liblcd204.c:94: return;
   021F 02s01r5B            983 	ljmp	_commandLcd
   0222                     984 00111$:
                            985 ;	liblcd204.c:96: else if( row == 1){
   0222 BE 01 0D            986 	cjne	r6,#0x01,00108$
   0225 BF 00 0A            987 	cjne	r7,#0x00,00108$
                            988 ;	liblcd204.c:97: commandLcd( 0xc0 + col );
   0228 AD*06               989 	mov	r5,_setCursorLcd_PARM_2
   022A 74 C0               990 	mov	a,#0xC0
   022C 2D                  991 	add	a,r5
   022D F5 82               992 	mov	dpl,a
                            993 ;	liblcd204.c:98: return;
   022F 02s01r5B            994 	ljmp	_commandLcd
   0232                     995 00108$:
                            996 ;	liblcd204.c:100: else if( row == 2 ){
   0232 BE 02 0D            997 	cjne	r6,#0x02,00105$
   0235 BF 00 0A            998 	cjne	r7,#0x00,00105$
                            999 ;	liblcd204.c:101: commandLcd( 0x94 + col );
   0238 AD*06              1000 	mov	r5,_setCursorLcd_PARM_2
   023A 74 94              1001 	mov	a,#0x94
   023C 2D                 1002 	add	a,r5
   023D F5 82              1003 	mov	dpl,a
                           1004 ;	liblcd204.c:102: return;
   023F 02s01r5B           1005 	ljmp	_commandLcd
   0242                    1006 00105$:
                           1007 ;	liblcd204.c:104: else if ( row == 3 ){
   0242 BE 03 0D           1008 	cjne	r6,#0x03,00102$
   0245 BF 00 0A           1009 	cjne	r7,#0x00,00102$
                           1010 ;	liblcd204.c:105: commandLcd( 0xd4+ col );
   0248 AF*06              1011 	mov	r7,_setCursorLcd_PARM_2
   024A 74 D4              1012 	mov	a,#0xD4
   024C 2F                 1013 	add	a,r7
   024D F5 82              1014 	mov	dpl,a
   024F 12s01r5B           1015 	lcall	_commandLcd
                           1016 ;	liblcd204.c:106: return;
                           1017 ;	liblcd204.c:109: return;
   0252                    1018 00102$:
   0252 22                 1019 	ret
                           1020 ;------------------------------------------------------------
                           1021 ;Allocation info for local variables in function 'IsBussy'
                           1022 ;------------------------------------------------------------
                           1023 ;	liblcd204.c:113: int IsBussy(){
                           1024 ;	-----------------------------------------
                           1025 ;	 function IsBussy
                           1026 ;	-----------------------------------------
   0253                    1027 _IsBussy:
                           1028 ;	liblcd204.c:115: LCD_BF   = 1;           //Make D7th bit of LCD as i/p
   0253 D2 A7              1029 	setb	_P2_7
                           1030 ;	liblcd204.c:116: EN_PIN   = 1;           //Make port pin as o/p
   0255 D2 A3              1031 	setb	_P2_3
                           1032 ;	liblcd204.c:117: RS_PIN   = 0;           //Selected command register
   0257 C2 A1              1033 	clr	_P2_1
                           1034 ;	liblcd204.c:118: RW_PIN   = 1;           //We are reading
   0259 D2 A2              1035 	setb	_P2_2
                           1036 ;	liblcd204.c:119: while(LCD_BF){          //read busy flag again and again till it becomes 0
   025B                    1037 00101$:
   025B 30 A7 06           1038 	jnb	_P2_7,00103$
                           1039 ;	liblcd204.c:120: EN_PIN   = 0;     //Enable H->L
   025E C2 A3              1040 	clr	_P2_3
                           1041 ;	liblcd204.c:121: EN_PIN   = 1;
   0260 D2 A3              1042 	setb	_P2_3
   0262 80 F7              1043 	sjmp	00101$
   0264                    1044 00103$:
                           1045 ;	liblcd204.c:124: return 0;
   0264 90 00 00           1046 	mov	dptr,#0x0000
   0267 22                 1047 	ret
                           1048 ;------------------------------------------------------------
                           1049 ;Allocation info for local variables in function 'clearLcdScreen'
                           1050 ;------------------------------------------------------------
                           1051 ;	liblcd204.c:127: void clearLcdScreen( void ){						//clear Screen of LCD.	
                           1052 ;	-----------------------------------------
                           1053 ;	 function clearLcdScreen
                           1054 ;	-----------------------------------------
   0268                    1055 _clearLcdScreen:
                           1056 ;	liblcd204.c:128: commandLcd( 0x01 );
   0268 75 82 01           1057 	mov	dpl,#0x01
   026B 12s01r5B           1058 	lcall	_commandLcd
                           1059 ;	liblcd204.c:129: home();	
   026E 02s02r71           1060 	ljmp	_home
                           1061 ;------------------------------------------------------------
                           1062 ;Allocation info for local variables in function 'home'
                           1063 ;------------------------------------------------------------
                           1064 ;	liblcd204.c:132: void home( void ){
                           1065 ;	-----------------------------------------
                           1066 ;	 function home
                           1067 ;	-----------------------------------------
   0271                    1068 _home:
                           1069 ;	liblcd204.c:133: commandLcd( 0x80 );
   0271 75 82 80           1070 	mov	dpl,#0x80
                           1071 ;	liblcd204.c:134: return;
   0274 02s01r5B           1072 	ljmp	_commandLcd
                           1073 ;------------------------------------------------------------
                           1074 ;Allocation info for local variables in function 'CursorOff'
                           1075 ;------------------------------------------------------------
                           1076 ;	liblcd204.c:137: void CursorOff( void ){
                           1077 ;	-----------------------------------------
                           1078 ;	 function CursorOff
                           1079 ;	-----------------------------------------
   0277                    1080 _CursorOff:
                           1081 ;	liblcd204.c:138: commandLcd( 0x0c);
   0277 75 82 0C           1082 	mov	dpl,#0x0C
   027A 02s01r5B           1083 	ljmp	_commandLcd
                           1084 ;------------------------------------------------------------
                           1085 ;Allocation info for local variables in function 'CursorOn'
                           1086 ;------------------------------------------------------------
                           1087 ;	liblcd204.c:141: void CursorOn( void ){
                           1088 ;	-----------------------------------------
                           1089 ;	 function CursorOn
                           1090 ;	-----------------------------------------
   027D                    1091 _CursorOn:
                           1092 ;	liblcd204.c:142: commandLcd( 0x0e);
   027D 75 82 0E           1093 	mov	dpl,#0x0E
   0280 02s01r5B           1094 	ljmp	_commandLcd
                           1095 ;------------------------------------------------------------
                           1096 ;Allocation info for local variables in function 'BlinkOff'
                           1097 ;------------------------------------------------------------
                           1098 ;	liblcd204.c:145: void BlinkOff( void ){
                           1099 ;	-----------------------------------------
                           1100 ;	 function BlinkOff
                           1101 ;	-----------------------------------------
   0283                    1102 _BlinkOff:
                           1103 ;	liblcd204.c:146: commandLcd( 0x0c );
   0283 75 82 0C           1104 	mov	dpl,#0x0C
   0286 02s01r5B           1105 	ljmp	_commandLcd
                           1106 ;------------------------------------------------------------
                           1107 ;Allocation info for local variables in function 'BlinkOn'
                           1108 ;------------------------------------------------------------
                           1109 ;	liblcd204.c:149: void BlinkOn ( void ){
                           1110 ;	-----------------------------------------
                           1111 ;	 function BlinkOn
                           1112 ;	-----------------------------------------
   0289                    1113 _BlinkOn:
                           1114 ;	liblcd204.c:150: commandLcd( 0x0d );
   0289 75 82 0D           1115 	mov	dpl,#0x0D
   028C 02s01r5B           1116 	ljmp	_commandLcd
                           1117 ;------------------------------------------------------------
                           1118 ;Allocation info for local variables in function 'MoveLeft'
                           1119 ;------------------------------------------------------------
                           1120 ;	liblcd204.c:153: void MoveLeft( void )								//move cursor to left by one character.
                           1121 ;	-----------------------------------------
                           1122 ;	 function MoveLeft
                           1123 ;	-----------------------------------------
   028F                    1124 _MoveLeft:
                           1125 ;	liblcd204.c:155: commandLcd( 0x10 );
   028F 75 82 10           1126 	mov	dpl,#0x10
   0292 02s01r5B           1127 	ljmp	_commandLcd
                           1128 ;------------------------------------------------------------
                           1129 ;Allocation info for local variables in function 'MoveRight'
                           1130 ;------------------------------------------------------------
                           1131 ;	liblcd204.c:158: void MoveRight( void )								// move cursor to right by one character.
                           1132 ;	-----------------------------------------
                           1133 ;	 function MoveRight
                           1134 ;	-----------------------------------------
   0295                    1135 _MoveRight:
                           1136 ;	liblcd204.c:160: commandLcd( 0x14 );
   0295 75 82 14           1137 	mov	dpl,#0x14
   0298 02s01r5B           1138 	ljmp	_commandLcd
                           1139 ;------------------------------------------------------------
                           1140 ;Allocation info for local variables in function 'ReadFromLcd'
                           1141 ;------------------------------------------------------------
                           1142 ;cCharDataUpperNibble      Allocated to registers r7 
                           1143 ;cCharDataLowerNibble      Allocated to registers r6 
                           1144 ;------------------------------------------------------------
                           1145 ;	liblcd204.c:163: unsigned char ReadFromLcd( ){
                           1146 ;	-----------------------------------------
                           1147 ;	 function ReadFromLcd
                           1148 ;	-----------------------------------------
   029B                    1149 _ReadFromLcd:
                           1150 ;	liblcd204.c:166: LCD_PORT=0xff;
   029B 75 A0 FF           1151 	mov	_P2,#0xFF
                           1152 ;	liblcd204.c:167: EN_PIN=1;
   029E D2 A3              1153 	setb	_P2_3
                           1154 ;	liblcd204.c:168: RW_PIN=1;
   02A0 D2 A2              1155 	setb	_P2_2
                           1156 ;	liblcd204.c:169: RS_PIN=1;
   02A2 D2 A1              1157 	setb	_P2_1
                           1158 ;	liblcd204.c:172: cCharDataUpperNibble = LCD_PORT;	
   02A4 AF A0              1159 	mov	r7,_P2
                           1160 ;	liblcd204.c:173: delay( 1 );
   02A6 90 00 01           1161 	mov	dptr,#0x0001
   02A9 C0 07              1162 	push	ar7
   02AB 12s00r00           1163 	lcall	_delay
   02AE D0 07              1164 	pop	ar7
                           1165 ;	liblcd204.c:174: cCharDataUpperNibble &= 0xf0;	
   02B0 53 07 F0           1166 	anl	ar7,#0xF0
                           1167 ;	liblcd204.c:175: EN_PIN=0;	
   02B3 C2 A3              1168 	clr	_P2_3
                           1169 ;	liblcd204.c:177: LCD_PORT=0xff;
   02B5 75 A0 FF           1170 	mov	_P2,#0xFF
                           1171 ;	liblcd204.c:179: EN_PIN=1;
   02B8 D2 A3              1172 	setb	_P2_3
                           1173 ;	liblcd204.c:180: cCharDataLowerNibble = LCD_PORT;
   02BA AE A0              1174 	mov	r6,_P2
                           1175 ;	liblcd204.c:181: delay( 1 );	
   02BC 90 00 01           1176 	mov	dptr,#0x0001
   02BF C0 07              1177 	push	ar7
   02C1 C0 06              1178 	push	ar6
   02C3 12s00r00           1179 	lcall	_delay
   02C6 D0 06              1180 	pop	ar6
   02C8 D0 07              1181 	pop	ar7
                           1182 ;	liblcd204.c:182: EN_PIN=0;
   02CA C2 A3              1183 	clr	_P2_3
                           1184 ;	liblcd204.c:184: cCharDataLowerNibble >>= 4;
   02CC EE                 1185 	mov	a,r6
   02CD C4                 1186 	swap	a
   02CE 54 0F              1187 	anl	a,#0x0F
   02D0 30 E3 02           1188 	jnb	acc.3,00103$
   02D3 44 F0              1189 	orl	a,#0xF0
   02D5                    1190 00103$:
                           1191 ;	liblcd204.c:185: cCharDataLowerNibble &= 0x0f;
                           1192 ;	liblcd204.c:186: cCharDataUpperNibble |= cCharDataLowerNibble;
   02D5 54 0F              1193 	anl	a,#0x0F
   02D7 42 07              1194 	orl	ar7,a
                           1195 ;	liblcd204.c:188: RW_PIN=0;	//for writting purpose.	
   02D9 C2 A2              1196 	clr	_P2_2
                           1197 ;	liblcd204.c:189: return cCharDataUpperNibble;
   02DB 8F 82              1198 	mov	dpl,r7
   02DD 22                 1199 	ret
                           1200 ;------------------------------------------------------------
                           1201 ;Allocation info for local variables in function 'ReadValueFrom'
                           1202 ;------------------------------------------------------------
                           1203 ;cLength                   Allocated with name '_ReadValueFrom_PARM_2'
                           1204 ;cStart                    Allocated to registers r6 r7 
                           1205 ;nIcnt                     Allocated to registers r2 r3 
                           1206 ;nVal                      Allocated to registers r4 r5 
                           1207 ;------------------------------------------------------------
                           1208 ;	liblcd204.c:192: int ReadValueFrom( int cStart, int cLength)			// char...starting position; length of the value in chararcters numbers...
                           1209 ;	-----------------------------------------
                           1210 ;	 function ReadValueFrom
                           1211 ;	-----------------------------------------
   02DE                    1212 _ReadValueFrom:
   02DE AE 82              1213 	mov	r6,dpl
   02E0 AF 83              1214 	mov	r7,dph
                           1215 ;	liblcd204.c:196: int nIcnt = 0, nVal = 0;
   02E2 7C 00              1216 	mov	r4,#0x00
   02E4 7D 00              1217 	mov	r5,#0x00
                           1218 ;	liblcd204.c:199: for( nIcnt = 0 ; nIcnt <= cLength ; nIcnt++ )
   02E6 7A 00              1219 	mov	r2,#0x00
   02E8 7B 00              1220 	mov	r3,#0x00
   02EA                    1221 00103$:
   02EA C3                 1222 	clr	c
   02EB E5*08              1223 	mov	a,_ReadValueFrom_PARM_2
   02ED 9A                 1224 	subb	a,r2
   02EE E5*09              1225 	mov	a,(_ReadValueFrom_PARM_2 + 1)
   02F0 64 80              1226 	xrl	a,#0x80
   02F2 8B F0              1227 	mov	b,r3
   02F4 63 F0 80           1228 	xrl	b,#0x80
   02F7 95 F0              1229 	subb	a,b
   02F9 50 03              1230 	jnc	00116$
   02FB 02s03r8C           1231 	ljmp	00106$
   02FE                    1232 00116$:
                           1233 ;	liblcd204.c:201: setCursorLcd( cStart, 5 + nIcnt );
   02FE 74 05              1234 	mov	a,#0x05
   0300 2A                 1235 	add	a,r2
   0301 F5*06              1236 	mov	_setCursorLcd_PARM_2,a
   0303 E4                 1237 	clr	a
   0304 3B                 1238 	addc	a,r3
   0305 F5*07              1239 	mov	(_setCursorLcd_PARM_2 + 1),a
   0307 8E 82              1240 	mov	dpl,r6
   0309 8F 83              1241 	mov	dph,r7
   030B C0 07              1242 	push	ar7
   030D C0 06              1243 	push	ar6
   030F C0 05              1244 	push	ar5
   0311 C0 04              1245 	push	ar4
   0313 C0 03              1246 	push	ar3
   0315 C0 02              1247 	push	ar2
   0317 12s02r10           1248 	lcall	_setCursorLcd
   031A D0 02              1249 	pop	ar2
   031C D0 03              1250 	pop	ar3
   031E D0 04              1251 	pop	ar4
   0320 D0 05              1252 	pop	ar5
   0322 D0 06              1253 	pop	ar6
   0324 D0 07              1254 	pop	ar7
                           1255 ;	liblcd204.c:202: if( nVal == 0){
   0326 EC                 1256 	mov	a,r4
   0327 4D                 1257 	orl	a,r5
   0328 70 1C              1258 	jnz	00102$
                           1259 ;	liblcd204.c:203: nVal = CharToInt( ReadFromLcd() );			
   032A C0 07              1260 	push	ar7
   032C C0 06              1261 	push	ar6
   032E C0 03              1262 	push	ar3
   0330 C0 02              1263 	push	ar2
   0332 12s02r9B           1264 	lcall	_ReadFromLcd
   0335 12s03r91           1265 	lcall	_CharToInt
   0338 AC 82              1266 	mov	r4,dpl
   033A AD 83              1267 	mov	r5,dph
   033C D0 02              1268 	pop	ar2
   033E D0 03              1269 	pop	ar3
   0340 D0 06              1270 	pop	ar6
   0342 D0 07              1271 	pop	ar7
                           1272 ;	liblcd204.c:204: continue;
   0344 80 3E              1273 	sjmp	00105$
   0346                    1274 00102$:
                           1275 ;	liblcd204.c:206: nVal *= 10;
   0346 8C*00              1276 	mov	__mulint_PARM_2,r4
   0348 8D*01              1277 	mov	(__mulint_PARM_2 + 1),r5
   034A 90 00 0A           1278 	mov	dptr,#0x000A
   034D C0 07              1279 	push	ar7
   034F C0 06              1280 	push	ar6
   0351 C0 03              1281 	push	ar3
   0353 C0 02              1282 	push	ar2
   0355 12s00r00           1283 	lcall	__mulint
   0358 AC 82              1284 	mov	r4,dpl
   035A AD 83              1285 	mov	r5,dph
   035C D0 02              1286 	pop	ar2
   035E D0 03              1287 	pop	ar3
                           1288 ;	liblcd204.c:207: nVal += CharToInt( ReadFromLcd() );			
   0360 C0 05              1289 	push	ar5
   0362 C0 04              1290 	push	ar4
   0364 C0 03              1291 	push	ar3
   0366 C0 02              1292 	push	ar2
   0368 12s02r9B           1293 	lcall	_ReadFromLcd
   036B 12s03r91           1294 	lcall	_CharToInt
   036E A8 82              1295 	mov	r0,dpl
   0370 A9 83              1296 	mov	r1,dph
   0372 D0 02              1297 	pop	ar2
   0374 D0 03              1298 	pop	ar3
   0376 D0 04              1299 	pop	ar4
   0378 D0 05              1300 	pop	ar5
   037A D0 06              1301 	pop	ar6
   037C D0 07              1302 	pop	ar7
   037E E8                 1303 	mov	a,r0
   037F 2C                 1304 	add	a,r4
   0380 FC                 1305 	mov	r4,a
   0381 E9                 1306 	mov	a,r1
   0382 3D                 1307 	addc	a,r5
   0383 FD                 1308 	mov	r5,a
   0384                    1309 00105$:
                           1310 ;	liblcd204.c:199: for( nIcnt = 0 ; nIcnt <= cLength ; nIcnt++ )
   0384 0A                 1311 	inc	r2
   0385 BA 00 01           1312 	cjne	r2,#0x00,00118$
   0388 0B                 1313 	inc	r3
   0389                    1314 00118$:
   0389 02s02rEA           1315 	ljmp	00103$
   038C                    1316 00106$:
                           1317 ;	liblcd204.c:210: return nVal;
   038C 8C 82              1318 	mov	dpl,r4
   038E 8D 83              1319 	mov	dph,r5
   0390 22                 1320 	ret
                           1321 ;------------------------------------------------------------
                           1322 ;Allocation info for local variables in function 'CharToInt'
                           1323 ;------------------------------------------------------------
                           1324 ;cCharDat                  Allocated to registers r7 
                           1325 ;nInt                      Allocated to registers 
                           1326 ;------------------------------------------------------------
                           1327 ;	liblcd204.c:214: int CharToInt( char cCharDat){
                           1328 ;	-----------------------------------------
                           1329 ;	 function CharToInt
                           1330 ;	-----------------------------------------
   0391                    1331 _CharToInt:
                           1332 ;	liblcd204.c:217: nInt = cCharDat - 48;
   0391 E5 82              1333 	mov	a,dpl
   0393 FF                 1334 	mov	r7,a
   0394 33                 1335 	rlc	a
   0395 95 E0              1336 	subb	a,acc
   0397 FE                 1337 	mov	r6,a
   0398 EF                 1338 	mov	a,r7
   0399 24 D0              1339 	add	a,#0xD0
   039B F5 82              1340 	mov	dpl,a
   039D EE                 1341 	mov	a,r6
   039E 34 FF              1342 	addc	a,#0xFF
   03A0 F5 83              1343 	mov	dph,a
                           1344 ;	liblcd204.c:218: return nInt;
   03A2 22                 1345 	ret
                           1346 ;------------------------------------------------------------
                           1347 ;Allocation info for local variables in function 'SplashScreenWindow'
                           1348 ;------------------------------------------------------------
                           1349 ;nCounterForLoop           Allocated to registers r6 r7 
                           1350 ;------------------------------------------------------------
                           1351 ;	liblcd204.c:222: void SplashScreenWindow( void ){
                           1352 ;	-----------------------------------------
                           1353 ;	 function SplashScreenWindow
                           1354 ;	-----------------------------------------
   03A3                    1355 _SplashScreenWindow:
                           1356 ;	liblcd204.c:224: clearLcdScreen();	
   03A3 12s02r68           1357 	lcall	_clearLcdScreen
                           1358 ;	liblcd204.c:225: CustomCharData();			//create all custom characters...
   03A6 12s04rC7           1359 	lcall	_CustomCharData
                           1360 ;	liblcd204.c:226: setCursorLcd( 0, 0);
   03A9 E4                 1361 	clr	a
   03AA F5*06              1362 	mov	_setCursorLcd_PARM_2,a
   03AC F5*07              1363 	mov	(_setCursorLcd_PARM_2 + 1),a
   03AE F5 82              1364 	mov	dpl,a
   03B0 F5 83              1365 	mov	dph,a
   03B2 12s02r10           1366 	lcall	_setCursorLcd
                           1367 ;	liblcd204.c:227: displayCharLcd(0);			//left Top
   03B5 75 82 00           1368 	mov	dpl,#0x00
   03B8 12s01r63           1369 	lcall	_displayCharLcd
                           1370 ;	liblcd204.c:228: for( nCounterForLoop = 1; nCounterForLoop< 19; nCounterForLoop++)
   03BB 7E 01              1371 	mov	r6,#0x01
   03BD 7F 00              1372 	mov	r7,#0x00
   03BF                    1373 00101$:
   03BF C3                 1374 	clr	c
   03C0 EE                 1375 	mov	a,r6
   03C1 94 13              1376 	subb	a,#0x13
   03C3 EF                 1377 	mov	a,r7
   03C4 64 80              1378 	xrl	a,#0x80
   03C6 94 80              1379 	subb	a,#0x80
   03C8 50 1F              1380 	jnc	00104$
                           1381 ;	liblcd204.c:230: setCursorLcd( 0, nCounterForLoop );
   03CA 8E*06              1382 	mov	_setCursorLcd_PARM_2,r6
   03CC 8F*07              1383 	mov	(_setCursorLcd_PARM_2 + 1),r7
   03CE 90 00 00           1384 	mov	dptr,#0x0000
   03D1 C0 07              1385 	push	ar7
   03D3 C0 06              1386 	push	ar6
   03D5 12s02r10           1387 	lcall	_setCursorLcd
                           1388 ;	liblcd204.c:231: displayCharLcd( 1 );		//topLine
   03D8 75 82 01           1389 	mov	dpl,#0x01
   03DB 12s01r63           1390 	lcall	_displayCharLcd
   03DE D0 06              1391 	pop	ar6
   03E0 D0 07              1392 	pop	ar7
                           1393 ;	liblcd204.c:228: for( nCounterForLoop = 1; nCounterForLoop< 19; nCounterForLoop++)
   03E2 0E                 1394 	inc	r6
   03E3 BE 00 D9           1395 	cjne	r6,#0x00,00101$
   03E6 0F                 1396 	inc	r7
   03E7 80 D6              1397 	sjmp	00101$
   03E9                    1398 00104$:
                           1399 ;	liblcd204.c:233: setCursorLcd( 0, 19 );
   03E9 75*06 13           1400 	mov	_setCursorLcd_PARM_2,#0x13
   03EC 75*07 00           1401 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   03EF 90 00 00           1402 	mov	dptr,#0x0000
   03F2 12s02r10           1403 	lcall	_setCursorLcd
                           1404 ;	liblcd204.c:234: displayCharLcd( 2 );		//Right Top	
   03F5 75 82 02           1405 	mov	dpl,#0x02
   03F8 12s01r63           1406 	lcall	_displayCharLcd
                           1407 ;	liblcd204.c:235: setCursorLcd( 1, 19);
   03FB 75*06 13           1408 	mov	_setCursorLcd_PARM_2,#0x13
   03FE 75*07 00           1409 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   0401 90 00 01           1410 	mov	dptr,#0x0001
   0404 12s02r10           1411 	lcall	_setCursorLcd
                           1412 ;	liblcd204.c:236: displayCharLcd( 4 );		//right Line
   0407 75 82 04           1413 	mov	dpl,#0x04
   040A 12s01r63           1414 	lcall	_displayCharLcd
                           1415 ;	liblcd204.c:237: setCursorLcd( 2, 19);
   040D 75*06 13           1416 	mov	_setCursorLcd_PARM_2,#0x13
   0410 75*07 00           1417 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   0413 90 00 02           1418 	mov	dptr,#0x0002
   0416 12s02r10           1419 	lcall	_setCursorLcd
                           1420 ;	liblcd204.c:238: displayCharLcd( 4 );		//right Line
   0419 75 82 04           1421 	mov	dpl,#0x04
   041C 12s01r63           1422 	lcall	_displayCharLcd
                           1423 ;	liblcd204.c:239: setCursorLcd( 3, 19);
   041F 75*06 13           1424 	mov	_setCursorLcd_PARM_2,#0x13
   0422 75*07 00           1425 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   0425 90 00 03           1426 	mov	dptr,#0x0003
   0428 12s02r10           1427 	lcall	_setCursorLcd
                           1428 ;	liblcd204.c:240: displayCharLcd( 6 );		//right bottom.
   042B 75 82 06           1429 	mov	dpl,#0x06
   042E 12s01r63           1430 	lcall	_displayCharLcd
                           1431 ;	liblcd204.c:242: for( nCounterForLoop = 18; nCounterForLoop>=0; nCounterForLoop--)
   0431 7E 12              1432 	mov	r6,#0x12
   0433 7F 00              1433 	mov	r7,#0x00
   0435                    1434 00105$:
   0435 EF                 1435 	mov	a,r7
   0436 20 E7 1F           1436 	jb	acc.7,00108$
                           1437 ;	liblcd204.c:244: setCursorLcd( 3, nCounterForLoop );
   0439 8E*06              1438 	mov	_setCursorLcd_PARM_2,r6
   043B 8F*07              1439 	mov	(_setCursorLcd_PARM_2 + 1),r7
   043D 90 00 03           1440 	mov	dptr,#0x0003
   0440 C0 07              1441 	push	ar7
   0442 C0 06              1442 	push	ar6
   0444 12s02r10           1443 	lcall	_setCursorLcd
                           1444 ;	liblcd204.c:245: displayCharLcd( 7 );		//bottom Dash
   0447 75 82 07           1445 	mov	dpl,#0x07
   044A 12s01r63           1446 	lcall	_displayCharLcd
   044D D0 06              1447 	pop	ar6
   044F D0 07              1448 	pop	ar7
                           1449 ;	liblcd204.c:242: for( nCounterForLoop = 18; nCounterForLoop>=0; nCounterForLoop--)
   0451 1E                 1450 	dec	r6
   0452 BE FF 01           1451 	cjne	r6,#0xFF,00124$
   0455 1F                 1452 	dec	r7
   0456                    1453 00124$:
   0456 80 DD              1454 	sjmp	00105$
   0458                    1455 00108$:
                           1456 ;	liblcd204.c:248: setCursorLcd( 3, 0 );
   0458 E4                 1457 	clr	a
   0459 F5*06              1458 	mov	_setCursorLcd_PARM_2,a
   045B F5*07              1459 	mov	(_setCursorLcd_PARM_2 + 1),a
   045D 90 00 03           1460 	mov	dptr,#0x0003
   0460 12s02r10           1461 	lcall	_setCursorLcd
                           1462 ;	liblcd204.c:249: displayCharLcd( 5 );
   0463 75 82 05           1463 	mov	dpl,#0x05
   0466 12s01r63           1464 	lcall	_displayCharLcd
                           1465 ;	liblcd204.c:251: setCursorLcd( 2, 0 );
   0469 E4                 1466 	clr	a
   046A F5*06              1467 	mov	_setCursorLcd_PARM_2,a
   046C F5*07              1468 	mov	(_setCursorLcd_PARM_2 + 1),a
   046E 90 00 02           1469 	mov	dptr,#0x0002
   0471 12s02r10           1470 	lcall	_setCursorLcd
                           1471 ;	liblcd204.c:252: displayCharLcd( 3 );
   0474 75 82 03           1472 	mov	dpl,#0x03
   0477 12s01r63           1473 	lcall	_displayCharLcd
                           1474 ;	liblcd204.c:253: setCursorLcd( 1, 0 );
   047A E4                 1475 	clr	a
   047B F5*06              1476 	mov	_setCursorLcd_PARM_2,a
   047D F5*07              1477 	mov	(_setCursorLcd_PARM_2 + 1),a
   047F 90 00 01           1478 	mov	dptr,#0x0001
   0482 12s02r10           1479 	lcall	_setCursorLcd
                           1480 ;	liblcd204.c:254: displayCharLcd( 3 );
   0485 75 82 03           1481 	mov	dpl,#0x03
   0488 12s01r63           1482 	lcall	_displayCharLcd
                           1483 ;	liblcd204.c:256: setCursorLcd( 1, 8 );
   048B 75*06 08           1484 	mov	_setCursorLcd_PARM_2,#0x08
   048E 75*07 00           1485 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   0491 90 00 01           1486 	mov	dptr,#0x0001
   0494 12s02r10           1487 	lcall	_setCursorLcd
                           1488 ;	liblcd204.c:257: displayStringLcd( "ECS" );	
   0497 90s00r40           1489 	mov	dptr,#__str_0
   049A 75 F0 80           1490 	mov	b,#0x80
   049D 12s01r6B           1491 	lcall	_displayStringLcd
                           1492 ;	liblcd204.c:259: setCursorLcd( 2, 3);
   04A0 75*06 03           1493 	mov	_setCursorLcd_PARM_2,#0x03
   04A3 75*07 00           1494 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   04A6 90 00 02           1495 	mov	dptr,#0x0002
   04A9 12s02r10           1496 	lcall	_setCursorLcd
                           1497 ;	liblcd204.c:260: displayStringLcd( "Elite Cab Suite" );
   04AC 90s00r44           1498 	mov	dptr,#__str_1
   04AF 75 F0 80           1499 	mov	b,#0x80
   04B2 12s01r6B           1500 	lcall	_displayStringLcd
                           1501 ;	liblcd204.c:262: setCursorLcd( 2, 1 );
   04B5 75*06 01           1502 	mov	_setCursorLcd_PARM_2,#0x01
   04B8 75*07 00           1503 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   04BB 90 00 02           1504 	mov	dptr,#0x0002
   04BE 12s02r10           1505 	lcall	_setCursorLcd
                           1506 ;	liblcd204.c:263: CursorOn();
   04C1 12s02r7D           1507 	lcall	_CursorOn
                           1508 ;	liblcd204.c:264: BlinkOn();
   04C4 02s02r89           1509 	ljmp	_BlinkOn
                           1510 ;------------------------------------------------------------
                           1511 ;Allocation info for local variables in function 'CustomCharData'
                           1512 ;------------------------------------------------------------
                           1513 ;cCntVar                   Allocated to registers r4 
                           1514 ;cCntVarB                  Allocated to registers r7 
                           1515 ;------------------------------------------------------------
                           1516 ;	liblcd204.c:267: void CustomCharData( void )						//build and prints The custom character...
                           1517 ;	-----------------------------------------
                           1518 ;	 function CustomCharData
                           1519 ;	-----------------------------------------
   04C7                    1520 _CustomCharData:
                           1521 ;	liblcd204.c:271: for( cCntVarB=0;cCntVarB<8; cCntVarB++)
   04C7 7F 00              1522 	mov	r7,#0x00
   04C9                    1523 00105$:
   04C9 BF 08 00           1524 	cjne	r7,#0x08,00121$
   04CC                    1525 00121$:
   04CC 50 49              1526 	jnc	00109$
                           1527 ;	liblcd204.c:273: commandLcd( 0x40 + (cCntVarB* 0x08));			//CGRAM 0th location...
   04CE EF                 1528 	mov	a,r7
   04CF C4                 1529 	swap	a
   04D0 03                 1530 	rr	a
   04D1 54 F8              1531 	anl	a,#0xF8
   04D3 FE                 1532 	mov	r6,a
   04D4 24 40              1533 	add	a,#0x40
   04D6 F5 82              1534 	mov	dpl,a
   04D8 C0 07              1535 	push	ar7
   04DA C0 06              1536 	push	ar6
   04DC 12s01r5B           1537 	lcall	_commandLcd
   04DF D0 06              1538 	pop	ar6
   04E1 D0 07              1539 	pop	ar7
                           1540 ;	liblcd204.c:274: for( cCntVar=0; cCntVar<8; cCntVar++)
   04E3 EE                 1541 	mov	a,r6
   04E4 24r00              1542 	add	a,#_cgram_Character_Slot
   04E6 FD                 1543 	mov	r5,a
   04E7 E4                 1544 	clr	a
   04E8 34s00              1545 	addc	a,#(_cgram_Character_Slot >> 8)
   04EA FE                 1546 	mov	r6,a
   04EB 7C 00              1547 	mov	r4,#0x00
   04ED                    1548 00101$:
   04ED BC 08 00           1549 	cjne	r4,#0x08,00123$
   04F0                    1550 00123$:
   04F0 50 22              1551 	jnc	00107$
                           1552 ;	liblcd204.c:276: displayCharLcd( cgram_Character_Slot[cCntVarB][cCntVar]);
   04F2 EC                 1553 	mov	a,r4
   04F3 2D                 1554 	add	a,r5
   04F4 F5 82              1555 	mov	dpl,a
   04F6 E4                 1556 	clr	a
   04F7 3E                 1557 	addc	a,r6
   04F8 F5 83              1558 	mov	dph,a
   04FA E4                 1559 	clr	a
   04FB 93                 1560 	movc	a,@a+dptr
   04FC F5 82              1561 	mov	dpl,a
   04FE C0 07              1562 	push	ar7
   0500 C0 06              1563 	push	ar6
   0502 C0 05              1564 	push	ar5
   0504 C0 04              1565 	push	ar4
   0506 12s01r63           1566 	lcall	_displayCharLcd
   0509 D0 04              1567 	pop	ar4
   050B D0 05              1568 	pop	ar5
   050D D0 06              1569 	pop	ar6
   050F D0 07              1570 	pop	ar7
                           1571 ;	liblcd204.c:274: for( cCntVar=0; cCntVar<8; cCntVar++)
   0511 0C                 1572 	inc	r4
   0512 80 D9              1573 	sjmp	00101$
   0514                    1574 00107$:
                           1575 ;	liblcd204.c:271: for( cCntVarB=0;cCntVarB<8; cCntVarB++)
   0514 0F                 1576 	inc	r7
   0515 80 B2              1577 	sjmp	00105$
   0517                    1578 00109$:
   0517 22                 1579 	ret
                           1580 ;------------------------------------------------------------
                           1581 ;Allocation info for local variables in function 'itwocStart'
                           1582 ;------------------------------------------------------------
                           1583 ;	libitwoc.c:16: void itwocStart()								//start the I2C communication as per the protocol 
                           1584 ;	-----------------------------------------
                           1585 ;	 function itwocStart
                           1586 ;	-----------------------------------------
   0518                    1587 _itwocStart:
                           1588 ;	libitwoc.c:18: if(SCL)
                           1589 ;	libitwoc.c:19: SCL = 0; /* Clear SCL */
   0518 10 91 02           1590 	jbc	_P1_1,00107$
   051B 80 00              1591 	sjmp	00102$
   051D                    1592 00107$:
   051D                    1593 00102$:
                           1594 ;	libitwoc.c:21: SDA = 1;        /* Set SDA */
   051D D2 92              1595 	setb	_P1_2
                           1596 ;	libitwoc.c:22: SCL = 1; /* Set SCL */
   051F D2 91              1597 	setb	_P1_1
                           1598 ;	libitwoc.c:24: itwocDelay();
   0521 12s05rC6           1599 	lcall	_itwocDelay
                           1600 ;	libitwoc.c:25: SDA = 0;        /* Clear SDA */
   0524 C2 92              1601 	clr	_P1_2
                           1602 ;	libitwoc.c:27: itwocDelay();
   0526 12s05rC6           1603 	lcall	_itwocDelay
                           1604 ;	libitwoc.c:28: SCL = 0;        /* Clear SCL */
   0529 C2 91              1605 	clr	_P1_1
   052B 22                 1606 	ret
                           1607 ;------------------------------------------------------------
                           1608 ;Allocation info for local variables in function 'itwocStop'
                           1609 ;------------------------------------------------------------
                           1610 ;	libitwoc.c:30: void itwocStop()										//stop the I2C communication
                           1611 ;	-----------------------------------------
                           1612 ;	 function itwocStop
                           1613 ;	-----------------------------------------
   052C                    1614 _itwocStop:
                           1615 ;	libitwoc.c:32: if(SCL)
                           1616 ;	libitwoc.c:33: SCL = 0; /* Clear SCL */
   052C 10 91 02           1617 	jbc	_P1_1,00107$
   052F 80 00              1618 	sjmp	00102$
   0531                    1619 00107$:
   0531                    1620 00102$:
                           1621 ;	libitwoc.c:35: SDA = 0; /* Clear SDA */
   0531 C2 92              1622 	clr	_P1_2
                           1623 ;	libitwoc.c:36: itwocDelay();
   0533 12s05rC6           1624 	lcall	_itwocDelay
                           1625 ;	libitwoc.c:38: SCL = 1; /* Set SCL */
   0536 D2 91              1626 	setb	_P1_1
                           1627 ;	libitwoc.c:39: itwocDelay();
   0538 12s05rC6           1628 	lcall	_itwocDelay
                           1629 ;	libitwoc.c:41: SDA = 1; /* Set SDA */
   053B D2 92              1630 	setb	_P1_2
   053D 22                 1631 	ret
                           1632 ;------------------------------------------------------------
                           1633 ;Allocation info for local variables in function 'itwocAck'
                           1634 ;------------------------------------------------------------
                           1635 ;	libitwoc.c:45: void itwocAck()										//send acknowledgement
                           1636 ;	-----------------------------------------
                           1637 ;	 function itwocAck
                           1638 ;	-----------------------------------------
   053E                    1639 _itwocAck:
                           1640 ;	libitwoc.c:47: SDA = 0; /* Clear SDA */
   053E C2 92              1641 	clr	_P1_2
                           1642 ;	libitwoc.c:48: itwocDelay();
   0540 12s05rC6           1643 	lcall	_itwocDelay
                           1644 ;	libitwoc.c:49: itwocDelay(); /* Call for send data to i2c bus */
   0543 12s05rC6           1645 	lcall	_itwocDelay
                           1646 ;	libitwoc.c:51: SDA = 1; /* Set SDA */
   0546 D2 92              1647 	setb	_P1_2
   0548 22                 1648 	ret
                           1649 ;------------------------------------------------------------
                           1650 ;Allocation info for local variables in function 'itwocNoAck'
                           1651 ;------------------------------------------------------------
                           1652 ;	libitwoc.c:53: void itwocNoAck()  								//send no ack.
                           1653 ;	-----------------------------------------
                           1654 ;	 function itwocNoAck
                           1655 ;	-----------------------------------------
   0549                    1656 _itwocNoAck:
                           1657 ;	libitwoc.c:55: SDA = 1; /* Set SDA */
   0549 D2 92              1658 	setb	_P1_2
                           1659 ;	libitwoc.c:57: itwocDelay();
   054B 12s05rC6           1660 	lcall	_itwocDelay
                           1661 ;	libitwoc.c:58: itwocClock(); /* Call for send data to i2c bus */
   054E 12s05r54           1662 	lcall	_itwocClock
                           1663 ;	libitwoc.c:60: SCL = 1; /* Set SCL */
   0551 D2 91              1664 	setb	_P1_1
   0553 22                 1665 	ret
                           1666 ;------------------------------------------------------------
                           1667 ;Allocation info for local variables in function 'itwocClock'
                           1668 ;------------------------------------------------------------
                           1669 ;	libitwoc.c:62: void itwocClock()									//i2c clock delay
                           1670 ;	-----------------------------------------
                           1671 ;	 function itwocClock
                           1672 ;	-----------------------------------------
   0554                    1673 _itwocClock:
                           1674 ;	libitwoc.c:64: itwocDelay();
   0554 12s05rC6           1675 	lcall	_itwocDelay
                           1676 ;	libitwoc.c:66: SCL = 1; /* Start clock */
   0557 D2 91              1677 	setb	_P1_1
                           1678 ;	libitwoc.c:68: itwocDelay();
   0559 12s05rC6           1679 	lcall	_itwocDelay
                           1680 ;	libitwoc.c:70: SCL = 0; /* Clear SCL */
   055C C2 91              1681 	clr	_P1_1
   055E 22                 1682 	ret
                           1683 ;------------------------------------------------------------
                           1684 ;Allocation info for local variables in function 'itwocSendByte'
                           1685 ;------------------------------------------------------------
                           1686 ;cI2cByte                  Allocated to registers r7 
                           1687 ;data_bit                  Allocated to registers r5 
                           1688 ;i                         Allocated to registers r6 
                           1689 ;------------------------------------------------------------
                           1690 ;	libitwoc.c:73: char itwocSendByte( unsigned char cI2cByte)								//sending byte of data in i2c channel
                           1691 ;	-----------------------------------------
                           1692 ;	 function itwocSendByte
                           1693 ;	-----------------------------------------
   055F                    1694 _itwocSendByte:
   055F AF 82              1695 	mov	r7,dpl
                           1696 ;	libitwoc.c:79: for(i=0;i<8;i++) /* For loop 8 time(send data 1 byte) */
   0561 7E 00              1697 	mov	r6,#0x00
   0563                    1698 00101$:
   0563 BE 08 00           1699 	cjne	r6,#0x08,00112$
   0566                    1700 00112$:
   0566 50 18              1701 	jnc	00104$
                           1702 ;	libitwoc.c:83: data_bit = cI2cByte & 0x80; /* Filter MSB bit keep to data_bit */
   0568 74 80              1703 	mov	a,#0x80
   056A 5F                 1704 	anl	a,r7
                           1705 ;	libitwoc.c:85: SDA = data_bit; /* Send data_bit to SDA */
   056B 24 FF              1706 	add	a,#0xff
   056D 92 92              1707 	mov	_P1_2,c
                           1708 ;	libitwoc.c:87: itwocClock();       /* Call for send data to i2c bus */
   056F C0 07              1709 	push	ar7
   0571 C0 06              1710 	push	ar6
   0573 12s05r54           1711 	lcall	_itwocClock
   0576 D0 06              1712 	pop	ar6
   0578 D0 07              1713 	pop	ar7
                           1714 ;	libitwoc.c:89: cI2cByte = cI2cByte<<1;
   057A EF                 1715 	mov	a,r7
   057B 2F                 1716 	add	a,r7
   057C FF                 1717 	mov	r7,a
                           1718 ;	libitwoc.c:79: for(i=0;i<8;i++) /* For loop 8 time(send data 1 byte) */
   057D 0E                 1719 	inc	r6
   057E 80 E3              1720 	sjmp	00101$
   0580                    1721 00104$:
                           1722 ;	libitwoc.c:92: SDA = 1; 						/* Set SDA */
   0580 D2 92              1723 	setb	_P1_2
                           1724 ;	libitwoc.c:94: itwocDelay(); 
   0582 12s05rC6           1725 	lcall	_itwocDelay
                           1726 ;	libitwoc.c:98: SCL = 1; /* Set SCL */
   0585 D2 91              1727 	setb	_P1_1
                           1728 ;	libitwoc.c:100: itwocDelay(); 
   0587 12s05rC6           1729 	lcall	_itwocDelay
                           1730 ;	libitwoc.c:102: data_bit = SDA;    /* Check acknowledge */
   058A A2 92              1731 	mov	c,_P1_2
   058C E4                 1732 	clr	a
   058D 33                 1733 	rlc	a
   058E FD                 1734 	mov	r5,a
                           1735 ;	libitwoc.c:104: SCL = 0; /* Clear SCL */
   058F C2 91              1736 	clr	_P1_1
                           1737 ;	libitwoc.c:106: itwocDelay();
   0591 C0 05              1738 	push	ar5
   0593 12s05rC6           1739 	lcall	_itwocDelay
   0596 D0 05              1740 	pop	ar5
                           1741 ;	libitwoc.c:108: return data_bit; /* If send_bit = 0 i2c is valid */   
   0598 8D 82              1742 	mov	dpl,r5
   059A 22                 1743 	ret
                           1744 ;------------------------------------------------------------
                           1745 ;Allocation info for local variables in function 'itwocGetByte'
                           1746 ;------------------------------------------------------------
                           1747 ;rd_bit                    Allocated to registers r5 
                           1748 ;i                         Allocated to registers r6 
                           1749 ;dat                       Allocated to registers r7 
                           1750 ;------------------------------------------------------------
                           1751 ;	libitwoc.c:111: unsigned char itwocGetByte( void )								//get byte of data from i2c channel .
                           1752 ;	-----------------------------------------
                           1753 ;	 function itwocGetByte
                           1754 ;	-----------------------------------------
   059B                    1755 _itwocGetByte:
                           1756 ;	libitwoc.c:117: dat = 0x00; 
   059B 7F 00              1757 	mov	r7,#0x00
                           1758 ;	libitwoc.c:119: for(i=0;i<8;i++) /* For loop read data 1 byte */
   059D 7E 00              1759 	mov	r6,#0x00
   059F                    1760 00101$:
   059F BE 08 00           1761 	cjne	r6,#0x08,00112$
   05A2                    1762 00112$:
   05A2 50 1F              1763 	jnc	00104$
                           1764 ;	libitwoc.c:123: itwocDelay();
   05A4 C0 07              1765 	push	ar7
   05A6 C0 06              1766 	push	ar6
   05A8 12s05rC6           1767 	lcall	_itwocDelay
                           1768 ;	libitwoc.c:125: SCL = 1; /* Set SCL */
   05AB D2 91              1769 	setb	_P1_1
                           1770 ;	libitwoc.c:127: itwocDelay();
   05AD 12s05rC6           1771 	lcall	_itwocDelay
   05B0 D0 06              1772 	pop	ar6
   05B2 D0 07              1773 	pop	ar7
                           1774 ;	libitwoc.c:129: rd_bit = SDA; /* Keep for check acknowledge */
   05B4 A2 92              1775 	mov	c,_P1_2
   05B6 E4                 1776 	clr	a
   05B7 33                 1777 	rlc	a
   05B8 FD                 1778 	mov	r5,a
                           1779 ;	libitwoc.c:131: dat = dat<<1; 
   05B9 EF                 1780 	mov	a,r7
   05BA 2F                 1781 	add	a,r7
                           1782 ;	libitwoc.c:133: dat = dat | rd_bit; /* Keep bit data in dat */
   05BB FC                 1783 	mov	r4,a
   05BC 4D                 1784 	orl	a,r5
   05BD FF                 1785 	mov	r7,a
                           1786 ;	libitwoc.c:135: SCL = 0; /* Clear SCL */
   05BE C2 91              1787 	clr	_P1_1
                           1788 ;	libitwoc.c:119: for(i=0;i<8;i++) /* For loop read data 1 byte */
   05C0 0E                 1789 	inc	r6
   05C1 80 DC              1790 	sjmp	00101$
   05C3                    1791 00104$:
                           1792 ;	libitwoc.c:139: return dat;
   05C3 8F 82              1793 	mov	dpl,r7
   05C5 22                 1794 	ret
                           1795 ;------------------------------------------------------------
                           1796 ;Allocation info for local variables in function 'itwocDelay'
                           1797 ;------------------------------------------------------------
                           1798 ;i                         Allocated to registers r7 
                           1799 ;------------------------------------------------------------
                           1800 ;	libitwoc.c:141: void itwocDelay()									//delay in i2c comm...
                           1801 ;	-----------------------------------------
                           1802 ;	 function itwocDelay
                           1803 ;	-----------------------------------------
   05C6                    1804 _itwocDelay:
                           1805 ;	libitwoc.c:145: for(i=0; i<0xff ; i++);
   05C6 7F FF              1806 	mov	r7,#0xFF
   05C8                    1807 00103$:
   05C8 8F 06              1808 	mov	ar6,r7
   05CA EE                 1809 	mov	a,r6
   05CB 14                 1810 	dec	a
   05CC FF                 1811 	mov	r7,a
   05CD 70 F9              1812 	jnz	00103$
   05CF 22                 1813 	ret
                           1814 ;------------------------------------------------------------
                           1815 ;Allocation info for local variables in function 'itwocIsACK'
                           1816 ;------------------------------------------------------------
                           1817 ;return_value              Allocated to registers 
                           1818 ;------------------------------------------------------------
                           1819 ;	libitwoc.c:147: char itwocIsACK()									//check for ACK information...
                           1820 ;	-----------------------------------------
                           1821 ;	 function itwocIsACK
                           1822 ;	-----------------------------------------
   05D0                    1823 _itwocIsACK:
                           1824 ;	libitwoc.c:153: SDA = 1;
   05D0 D2 92              1825 	setb	_P1_2
                           1826 ;	libitwoc.c:154: itwocDelay();
   05D2 12s05rC6           1827 	lcall	_itwocDelay
                           1828 ;	libitwoc.c:155: SCL = 1;
   05D5 D2 91              1829 	setb	_P1_1
                           1830 ;	libitwoc.c:156: itwocDelay();
   05D7 12s05rC6           1831 	lcall	_itwocDelay
                           1832 ;	libitwoc.c:158: return_value = ~SDA;	// invert
   05DA A2 92              1833 	mov	c,_P1_2
   05DC E4                 1834 	clr	a
   05DD 33                 1835 	rlc	a
   05DE F4                 1836 	cpl	a
   05DF F5 82              1837 	mov	dpl,a
                           1838 ;	libitwoc.c:159: SCL = 0;
   05E1 C2 91              1839 	clr	_P1_1
                           1840 ;	libitwoc.c:160: return return_value; // 1=ACK 0=NACK
   05E3 22                 1841 	ret
                           1842 ;------------------------------------------------------------
                           1843 ;Allocation info for local variables in function 'eepromStart'
                           1844 ;------------------------------------------------------------
                           1845 ;	libeeprom256.c:22: void eepromStart()
                           1846 ;	-----------------------------------------
                           1847 ;	 function eepromStart
                           1848 ;	-----------------------------------------
   05E4                    1849 _eepromStart:
                           1850 ;	libeeprom256.c:24: SDA=1;
   05E4 D2 92              1851 	setb	_P1_2
                           1852 ;	libeeprom256.c:25: SCL=1;
   05E6 D2 91              1853 	setb	_P1_1
                           1854 ;	libeeprom256.c:26: _nop_();         //No operation
   05E8 12s06r29           1855 	lcall	__nop_
                           1856 ;	libeeprom256.c:27: SDA=0;
   05EB C2 92              1857 	clr	_P1_2
                           1858 ;	libeeprom256.c:28: _nop_();
   05ED 12s06r29           1859 	lcall	__nop_
                           1860 ;	libeeprom256.c:29: SCL=0;
   05F0 C2 91              1861 	clr	_P1_1
   05F2 22                 1862 	ret
                           1863 ;------------------------------------------------------------
                           1864 ;Allocation info for local variables in function 'eepromStop'
                           1865 ;------------------------------------------------------------
                           1866 ;	libeeprom256.c:31: void eepromStop()
                           1867 ;	-----------------------------------------
                           1868 ;	 function eepromStop
                           1869 ;	-----------------------------------------
   05F3                    1870 _eepromStop:
                           1871 ;	libeeprom256.c:33: SDA=0;
   05F3 C2 92              1872 	clr	_P1_2
                           1873 ;	libeeprom256.c:34: SCL = 1;
   05F5 D2 91              1874 	setb	_P1_1
                           1875 ;	libeeprom256.c:35: _nop_();
   05F7 12s06r29           1876 	lcall	__nop_
                           1877 ;	libeeprom256.c:37: SDA=1;
   05FA D2 92              1878 	setb	_P1_2
                           1879 ;	libeeprom256.c:38: _nop_();
   05FC 12s06r29           1880 	lcall	__nop_
                           1881 ;	libeeprom256.c:39: SCL = 0;
   05FF C2 91              1882 	clr	_P1_1
   0601 22                 1883 	ret
                           1884 ;------------------------------------------------------------
                           1885 ;Allocation info for local variables in function 'eepromAck'
                           1886 ;------------------------------------------------------------
                           1887 ;	libeeprom256.c:41: void eepromAck()
                           1888 ;	-----------------------------------------
                           1889 ;	 function eepromAck
                           1890 ;	-----------------------------------------
   0602                    1891 _eepromAck:
                           1892 ;	libeeprom256.c:43: SDA = 0;
   0602 C2 92              1893 	clr	_P1_2
                           1894 ;	libeeprom256.c:44: SCL=1;
   0604 D2 91              1895 	setb	_P1_1
                           1896 ;	libeeprom256.c:45: _nop_();
   0606 12s06r29           1897 	lcall	__nop_
                           1898 ;	libeeprom256.c:46: SCL=0;
   0609 C2 91              1899 	clr	_P1_1
                           1900 ;	libeeprom256.c:47: SDA = 1;
   060B D2 92              1901 	setb	_P1_2
   060D 22                 1902 	ret
                           1903 ;------------------------------------------------------------
                           1904 ;Allocation info for local variables in function 'eepromNoAck'
                           1905 ;------------------------------------------------------------
                           1906 ;	libeeprom256.c:49: void eepromNoAck()
                           1907 ;	-----------------------------------------
                           1908 ;	 function eepromNoAck
                           1909 ;	-----------------------------------------
   060E                    1910 _eepromNoAck:
                           1911 ;	libeeprom256.c:51: SDA = 1;		/* Set SDA */
   060E D2 92              1912 	setb	_P1_2
                           1913 ;	libeeprom256.c:52: _nop_();
   0610 12s06r29           1914 	lcall	__nop_
                           1915 ;	libeeprom256.c:53: eepromClock();		//give a clock...
   0613 12s06r19           1916 	lcall	_eepromClock
                           1917 ;	libeeprom256.c:54: SCL = 1;		/* Set SCL */
   0616 D2 91              1918 	setb	_P1_1
   0618 22                 1919 	ret
                           1920 ;------------------------------------------------------------
                           1921 ;Allocation info for local variables in function 'eepromClock'
                           1922 ;------------------------------------------------------------
                           1923 ;	libeeprom256.c:56: void eepromClock()
                           1924 ;	-----------------------------------------
                           1925 ;	 function eepromClock
                           1926 ;	-----------------------------------------
   0619                    1927 _eepromClock:
                           1928 ;	libeeprom256.c:58: SCL = 1;
   0619 D2 91              1929 	setb	_P1_1
                           1930 ;	libeeprom256.c:59: _nop_();
   061B 12s06r29           1931 	lcall	__nop_
                           1932 ;	libeeprom256.c:60: _nop_();
   061E 12s06r29           1933 	lcall	__nop_
                           1934 ;	libeeprom256.c:61: SCL = 0;
   0621 C2 91              1935 	clr	_P1_1
                           1936 ;	libeeprom256.c:62: _nop_();
   0623 12s06r29           1937 	lcall	__nop_
                           1938 ;	libeeprom256.c:63: _nop_();
   0626 02s06r29           1939 	ljmp	__nop_
                           1940 ;------------------------------------------------------------
                           1941 ;Allocation info for local variables in function '_nop_'
                           1942 ;------------------------------------------------------------
                           1943 ;	libeeprom256.c:65: void _nop_()
                           1944 ;	-----------------------------------------
                           1945 ;	 function _nop_
                           1946 ;	-----------------------------------------
   0629                    1947 __nop_:
                           1948 ;	libeeprom256.c:69: __endasm;
   0629 00                 1949 	nop
   062A 22                 1950 	ret
                           1951 ;------------------------------------------------------------
                           1952 ;Allocation info for local variables in function 'eepromWriteTo'
                           1953 ;------------------------------------------------------------
                           1954 ;ucAddrTo                  Allocated with name '_eepromWriteTo_PARM_2'
                           1955 ;ucDataVal                 Allocated to registers r7 
                           1956 ;------------------------------------------------------------
                           1957 ;	libeeprom256.c:71: void eepromWriteTo(  unsigned char ucDataVal, unsigned char ucAddrTo)
                           1958 ;	-----------------------------------------
                           1959 ;	 function eepromWriteTo
                           1960 ;	-----------------------------------------
   062B                    1961 _eepromWriteTo:
   062B AF 82              1962 	mov	r7,dpl
                           1963 ;	libeeprom256.c:73: eepromStart();
   062D C0 07              1964 	push	ar7
   062F 12s05rE4           1965 	lcall	_eepromStart
                           1966 ;	libeeprom256.c:74: eepromSendByte(AT_EEPROM_ADDR); //device address
   0632 75 82 A0           1967 	mov	dpl,#0xA0
   0635 12s06r9B           1968 	lcall	_eepromSendByte
                           1969 ;	libeeprom256.c:75: eepromAck();
   0638 12s06r02           1970 	lcall	_eepromAck
                           1971 ;	libeeprom256.c:76: eepromSendByte( 0x00 );
   063B 75 82 00           1972 	mov	dpl,#0x00
   063E 12s06r9B           1973 	lcall	_eepromSendByte
                           1974 ;	libeeprom256.c:77: eepromAck();
   0641 12s06r02           1975 	lcall	_eepromAck
                           1976 ;	libeeprom256.c:78: eepromSendByte(ucAddrTo); //word address
   0644 85*0A 82           1977 	mov	dpl,_eepromWriteTo_PARM_2
   0647 12s06r9B           1978 	lcall	_eepromSendByte
                           1979 ;	libeeprom256.c:79: eepromAck();
   064A 12s06r02           1980 	lcall	_eepromAck
   064D D0 07              1981 	pop	ar7
                           1982 ;	libeeprom256.c:80: eepromSendByte( ucDataVal );
   064F 8F 82              1983 	mov	dpl,r7
   0651 12s06r9B           1984 	lcall	_eepromSendByte
                           1985 ;	libeeprom256.c:81: eepromAck();
   0654 12s06r02           1986 	lcall	_eepromAck
                           1987 ;	libeeprom256.c:82: eepromStop();
                           1988 ;	libeeprom256.c:84: return;
   0657 02s05rF3           1989 	ljmp	_eepromStop
                           1990 ;------------------------------------------------------------
                           1991 ;Allocation info for local variables in function 'eepromReadFrom'
                           1992 ;------------------------------------------------------------
                           1993 ;ucAddrToReadFrom          Allocated to registers r7 
                           1994 ;eepromDataVal             Allocated to registers r7 
                           1995 ;------------------------------------------------------------
                           1996 ;	libeeprom256.c:86: unsigned char eepromReadFrom( unsigned  char ucAddrToReadFrom)
                           1997 ;	-----------------------------------------
                           1998 ;	 function eepromReadFrom
                           1999 ;	-----------------------------------------
   065A                    2000 _eepromReadFrom:
   065A AF 82              2001 	mov	r7,dpl
                           2002 ;	libeeprom256.c:89: eepromStart();
   065C C0 07              2003 	push	ar7
   065E 12s05rE4           2004 	lcall	_eepromStart
                           2005 ;	libeeprom256.c:90: eepromSendByte(AT_EEPROM_ADDR); 	//device address
   0661 75 82 A0           2006 	mov	dpl,#0xA0
   0664 12s06r9B           2007 	lcall	_eepromSendByte
                           2008 ;	libeeprom256.c:91: eepromAck();
   0667 12s06r02           2009 	lcall	_eepromAck
                           2010 ;	libeeprom256.c:92: eepromSendByte( 0x00 );
   066A 75 82 00           2011 	mov	dpl,#0x00
   066D 12s06r9B           2012 	lcall	_eepromSendByte
                           2013 ;	libeeprom256.c:93: eepromAck();
   0670 12s06r02           2014 	lcall	_eepromAck
   0673 D0 07              2015 	pop	ar7
                           2016 ;	libeeprom256.c:94: eepromSendByte(ucAddrToReadFrom); 	//word address
   0675 8F 82              2017 	mov	dpl,r7
   0677 12s06r9B           2018 	lcall	_eepromSendByte
                           2019 ;	libeeprom256.c:95: eepromAck();
   067A 12s06r02           2020 	lcall	_eepromAck
                           2021 ;	libeeprom256.c:96: eepromStart();
   067D 12s05rE4           2022 	lcall	_eepromStart
                           2023 ;	libeeprom256.c:97: eepromSendByte(AT_EEPROM_ADDR + 1);  	//device address to connect in Read Mode.
   0680 75 82 A1           2024 	mov	dpl,#0xA1
   0683 12s06r9B           2025 	lcall	_eepromSendByte
                           2026 ;	libeeprom256.c:98: eepromAck();
   0686 12s06r02           2027 	lcall	_eepromAck
                           2028 ;	libeeprom256.c:99: eepromDataVal = eepromReadByte();
   0689 12s06rC5           2029 	lcall	_eepromReadByte
   068C AF 82              2030 	mov	r7,dpl
                           2031 ;	libeeprom256.c:100: eepromNoAck();
   068E C0 07              2032 	push	ar7
   0690 12s06r0E           2033 	lcall	_eepromNoAck
                           2034 ;	libeeprom256.c:101: eepromStop();
   0693 12s05rF3           2035 	lcall	_eepromStop
   0696 D0 07              2036 	pop	ar7
                           2037 ;	libeeprom256.c:103: return eepromDataVal;
   0698 8F 82              2038 	mov	dpl,r7
   069A 22                 2039 	ret
                           2040 ;------------------------------------------------------------
                           2041 ;Allocation info for local variables in function 'eepromSendByte'
                           2042 ;------------------------------------------------------------
                           2043 ;ucValToSend               Allocated to registers r7 
                           2044 ;i                         Allocated to registers r6 
                           2045 ;------------------------------------------------------------
                           2046 ;	libeeprom256.c:105: void eepromSendByte(  unsigned char ucValToSend)
                           2047 ;	-----------------------------------------
                           2048 ;	 function eepromSendByte
                           2049 ;	-----------------------------------------
   069B                    2050 _eepromSendByte:
   069B AF 82              2051 	mov	r7,dpl
                           2052 ;	libeeprom256.c:108: SCL = 0;			//pull SCL low for gettting SDA ready..
   069D C2 91              2053 	clr	_P1_1
                           2054 ;	libeeprom256.c:109: for(i=0;i<8;i++)
   069F 7E 00              2055 	mov	r6,#0x00
   06A1                    2056 00101$:
   06A1 C3                 2057 	clr	c
   06A2 EE                 2058 	mov	a,r6
   06A3 64 80              2059 	xrl	a,#0x80
   06A5 94 88              2060 	subb	a,#0x88
   06A7 50 1B              2061 	jnc	00104$
                           2062 ;	libeeprom256.c:111: SDA=ucValToSend & 0x80; //extracting MSB	
   06A9 EF                 2063 	mov	a,r7
   06AA 33                 2064 	rlc	a
   06AB 92*00              2065 	mov  _eepromSendByte_sloc0_1_0,c
   06AD 92 92              2066 	mov	_P1_2,c
                           2067 ;	libeeprom256.c:112: SCL=1;	
   06AF D2 91              2068 	setb	_P1_1
                           2069 ;	libeeprom256.c:113: _nop_();
   06B1 C0 07              2070 	push	ar7
   06B3 C0 06              2071 	push	ar6
   06B5 12s06r29           2072 	lcall	__nop_
   06B8 D0 06              2073 	pop	ar6
   06BA D0 07              2074 	pop	ar7
                           2075 ;	libeeprom256.c:114: SCL=0;
   06BC C2 91              2076 	clr	_P1_1
                           2077 ;	libeeprom256.c:115: ucValToSend=ucValToSend<<1; //shiftng left
   06BE EF                 2078 	mov	a,r7
   06BF 2F                 2079 	add	a,r7
   06C0 FF                 2080 	mov	r7,a
                           2081 ;	libeeprom256.c:109: for(i=0;i<8;i++)
   06C1 0E                 2082 	inc	r6
   06C2 80 DD              2083 	sjmp	00101$
   06C4                    2084 00104$:
                           2085 ;	libeeprom256.c:118: return;
   06C4 22                 2086 	ret
                           2087 ;------------------------------------------------------------
                           2088 ;Allocation info for local variables in function 'eepromReadByte'
                           2089 ;------------------------------------------------------------
                           2090 ;i                         Allocated to registers r6 
                           2091 ;reeadVal                  Allocated to registers r7 
                           2092 ;ucDt                      Allocated to registers r5 
                           2093 ;------------------------------------------------------------
                           2094 ;	libeeprom256.c:121: unsigned char eepromReadByte()
                           2095 ;	-----------------------------------------
                           2096 ;	 function eepromReadByte
                           2097 ;	-----------------------------------------
   06C5                    2098 _eepromReadByte:
                           2099 ;	libeeprom256.c:123: char i, reeadVal=0x00;
   06C5 7F 00              2100 	mov	r7,#0x00
                           2101 ;	libeeprom256.c:126: for(i=0;i<8;i++)
   06C7 7E 00              2102 	mov	r6,#0x00
   06C9                    2103 00101$:
   06C9 C3                 2104 	clr	c
   06CA EE                 2105 	mov	a,r6
   06CB 64 80              2106 	xrl	a,#0x80
   06CD 94 88              2107 	subb	a,#0x88
   06CF 50 11              2108 	jnc	00104$
                           2109 ;	libeeprom256.c:128: SCL=1;	
   06D1 D2 91              2110 	setb	_P1_1
                           2111 ;	libeeprom256.c:129: ucDt = SDA;		
   06D3 A2 92              2112 	mov	c,_P1_2
   06D5 E4                 2113 	clr	a
   06D6 33                 2114 	rlc	a
                           2115 ;	libeeprom256.c:130: reeadVal = reeadVal | ucDt;
   06D7 FD                 2116 	mov	r5,a
   06D8 42 07              2117 	orl	ar7,a
                           2118 ;	libeeprom256.c:131: reeadVal <<= 1;	
   06DA EF                 2119 	mov	a,r7
   06DB 2F                 2120 	add	a,r7
   06DC FF                 2121 	mov	r7,a
                           2122 ;	libeeprom256.c:133: SCL=0;			
   06DD C2 91              2123 	clr	_P1_1
                           2124 ;	libeeprom256.c:126: for(i=0;i<8;i++)
   06DF 0E                 2125 	inc	r6
   06E0 80 E7              2126 	sjmp	00101$
   06E2                    2127 00104$:
                           2128 ;	libeeprom256.c:136: return reeadVal;				//Returns 8 bit data here
   06E2 8F 82              2129 	mov	dpl,r7
   06E4 22                 2130 	ret
                           2131 ;------------------------------------------------------------
                           2132 ;Allocation info for local variables in function 'eepromReset'
                           2133 ;------------------------------------------------------------
                           2134 ;i                         Allocated to registers r7 
                           2135 ;------------------------------------------------------------
                           2136 ;	libeeprom256.c:140: void eepromReset()
                           2137 ;	-----------------------------------------
                           2138 ;	 function eepromReset
                           2139 ;	-----------------------------------------
   06E5                    2140 _eepromReset:
                           2141 ;	libeeprom256.c:143: eepromStart();
   06E5 12s05rE4           2142 	lcall	_eepromStart
                           2143 ;	libeeprom256.c:144: _nop_();
   06E8 12s06r29           2144 	lcall	__nop_
                           2145 ;	libeeprom256.c:145: for(i=0;i<10;i++)
   06EB 7F 00              2146 	mov	r7,#0x00
   06ED                    2147 00101$:
   06ED C3                 2148 	clr	c
   06EE EF                 2149 	mov	a,r7
   06EF 64 80              2150 	xrl	a,#0x80
   06F1 94 8A              2151 	subb	a,#0x8a
   06F3 50 0C              2152 	jnc	00104$
                           2153 ;	libeeprom256.c:147: SCL=~SCL;
   06F5 D2 91              2154 	setb	_P1_1
                           2155 ;	libeeprom256.c:148: _nop_();
   06F7 C0 07              2156 	push	ar7
   06F9 12s06r29           2157 	lcall	__nop_
   06FC D0 07              2158 	pop	ar7
                           2159 ;	libeeprom256.c:145: for(i=0;i<10;i++)
   06FE 0F                 2160 	inc	r7
   06FF 80 EC              2161 	sjmp	00101$
   0701                    2162 00104$:
                           2163 ;	libeeprom256.c:150: eepromStart();
   0701 12s05rE4           2164 	lcall	_eepromStart
                           2165 ;	libeeprom256.c:151: _nop_();
   0704 12s06r29           2166 	lcall	__nop_
                           2167 ;	libeeprom256.c:152: eepromStop();
                           2168 ;	libeeprom256.c:153: return;
   0707 02s05rF3           2169 	ljmp	_eepromStop
                           2170 ;------------------------------------------------------------
                           2171 ;Allocation info for local variables in function 'showRtcDateDay'
                           2172 ;------------------------------------------------------------
                           2173 ;	librtc.c:7: void showRtcDateDay()					//Show RTC Date-Day...
                           2174 ;	-----------------------------------------
                           2175 ;	 function showRtcDateDay
                           2176 ;	-----------------------------------------
   070A                    2177 _showRtcDateDay:
                           2178 ;	librtc.c:9: RTC_sendToDisplay( RTC_get( DATE ) );
   070A 75 82 04           2179 	mov	dpl,#0x04
   070D 12s07rAF           2180 	lcall	_RTC_get
   0710 12s08rAB           2181 	lcall	_RTC_sendToDisplay
                           2182 ;	librtc.c:10: displayCharLcd( '-' );
   0713 75 82 2D           2183 	mov	dpl,#0x2D
   0716 12s01r63           2184 	lcall	_displayCharLcd
                           2185 ;	librtc.c:11: RTC_sendToDisplay( RTC_get( MONTH ) );
   0719 75 82 05           2186 	mov	dpl,#0x05
   071C 12s07rAF           2187 	lcall	_RTC_get
   071F 12s08rAB           2188 	lcall	_RTC_sendToDisplay
                           2189 ;	librtc.c:12: displayCharLcd( '-' );
   0722 75 82 2D           2190 	mov	dpl,#0x2D
   0725 12s01r63           2191 	lcall	_displayCharLcd
                           2192 ;	librtc.c:13: RTC_sendToDisplay( RTC_get( YEAR ) );
   0728 75 82 06           2193 	mov	dpl,#0x06
   072B 12s07rAF           2194 	lcall	_RTC_get
   072E 02s08rAB           2195 	ljmp	_RTC_sendToDisplay
                           2196 ;------------------------------------------------------------
                           2197 ;Allocation info for local variables in function 'showRtc'
                           2198 ;------------------------------------------------------------
                           2199 ;val                       Allocated with name '_showRtc_val_1_141'
                           2200 ;------------------------------------------------------------
                           2201 ;	librtc.c:15: void showRtc()					//Shows the RTC ...
                           2202 ;	-----------------------------------------
                           2203 ;	 function showRtc
                           2204 ;	-----------------------------------------
   0731                    2205 _showRtc:
                           2206 ;	librtc.c:19: val[0] = RTC_get( SEC );
   0731 75 82 00           2207 	mov	dpl,#0x00
   0734 12s07rAF           2208 	lcall	_RTC_get
   0737 E5 82              2209 	mov	a,dpl
   0739 F5*0B              2210 	mov	_showRtc_val_1_141,a
                           2211 ;	librtc.c:20: val[1] = RTC_get( MIN );
   073B 75 82 01           2212 	mov	dpl,#0x01
   073E 12s07rAF           2213 	lcall	_RTC_get
   0741 E5 82              2214 	mov	a,dpl
   0743 F5*0C              2215 	mov	(_showRtc_val_1_141 + 0x0001),a
                           2216 ;	librtc.c:21: val[2] = RTC_get( HOUR );
   0745 75 82 02           2217 	mov	dpl,#0x02
   0748 12s07rAF           2218 	lcall	_RTC_get
   074B E5 82              2219 	mov	a,dpl
   074D F5*0D              2220 	mov	(_showRtc_val_1_141 + 0x0002),a
                           2221 ;	librtc.c:22: val[3] = RTC_get( DATE );
   074F 75 82 04           2222 	mov	dpl,#0x04
   0752 12s07rAF           2223 	lcall	_RTC_get
   0755 E5 82              2224 	mov	a,dpl
   0757 F5*0E              2225 	mov	(_showRtc_val_1_141 + 0x0003),a
                           2226 ;	librtc.c:23: val[4] = RTC_get( MONTH );
   0759 75 82 05           2227 	mov	dpl,#0x05
   075C 12s07rAF           2228 	lcall	_RTC_get
   075F E5 82              2229 	mov	a,dpl
   0761 F5*0F              2230 	mov	(_showRtc_val_1_141 + 0x0004),a
                           2231 ;	librtc.c:24: val[5] = RTC_get( YEAR );
   0763 75 82 06           2232 	mov	dpl,#0x06
   0766 12s07rAF           2233 	lcall	_RTC_get
   0769 E5 82              2234 	mov	a,dpl
   076B F5*10              2235 	mov	(_showRtc_val_1_141 + 0x0005),a
                           2236 ;	librtc.c:26: setCursorLcd( 1, 1);
   076D 75*06 01           2237 	mov	_setCursorLcd_PARM_2,#0x01
   0770 75*07 00           2238 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   0773 90 00 01           2239 	mov	dptr,#0x0001
   0776 12s02r10           2240 	lcall	_setCursorLcd
                           2241 ;	librtc.c:27: RTC_sendToDisplay((val[2]) );
   0779 85*0D 82           2242 	mov	dpl,(_showRtc_val_1_141 + 0x0002)
   077C 12s08rAB           2243 	lcall	_RTC_sendToDisplay
                           2244 ;	librtc.c:28: displayCharLcd(':');
   077F 75 82 3A           2245 	mov	dpl,#0x3A
   0782 12s01r63           2246 	lcall	_displayCharLcd
                           2247 ;	librtc.c:29: RTC_sendToDisplay( (val[1]) );
   0785 85*0C 82           2248 	mov	dpl,(_showRtc_val_1_141 + 0x0001)
   0788 12s08rAB           2249 	lcall	_RTC_sendToDisplay
                           2250 ;	librtc.c:30: displayCharLcd(':');
   078B 75 82 3A           2251 	mov	dpl,#0x3A
   078E 12s01r63           2252 	lcall	_displayCharLcd
                           2253 ;	librtc.c:31: RTC_sendToDisplay( (val[0]) );	
   0791 85*0B 82           2254 	mov	dpl,_showRtc_val_1_141
   0794 02s08rAB           2255 	ljmp	_RTC_sendToDisplay
                           2256 ;------------------------------------------------------------
                           2257 ;Allocation info for local variables in function 'startRtc'
                           2258 ;------------------------------------------------------------
                           2259 ;	librtc.c:33: void startRtc()						//I2C Start Protocol.
                           2260 ;	-----------------------------------------
                           2261 ;	 function startRtc
                           2262 ;	-----------------------------------------
   0797                    2263 _startRtc:
                           2264 ;	librtc.c:35: itwocStart();	//srating i2c communication...
   0797 02s05r18           2265 	ljmp	_itwocStart
                           2266 ;------------------------------------------------------------
                           2267 ;Allocation info for local variables in function 'rtcSendData'
                           2268 ;------------------------------------------------------------
                           2269 ;dat                       Allocated to registers 
                           2270 ;------------------------------------------------------------
                           2271 ;	librtc.c:39: char rtcSendData(unsigned char dat)		//Send data to RTC.
                           2272 ;	-----------------------------------------
                           2273 ;	 function rtcSendData
                           2274 ;	-----------------------------------------
   079A                    2275 _rtcSendData:
                           2276 ;	librtc.c:41: return itwocSendByte( dat );
   079A 02s05r5F           2277 	ljmp	_itwocSendByte
                           2278 ;------------------------------------------------------------
                           2279 ;Allocation info for local variables in function 'rtcAck'
                           2280 ;------------------------------------------------------------
                           2281 ;	librtc.c:44: void rtcAck()							//send Acknowledgement...
                           2282 ;	-----------------------------------------
                           2283 ;	 function rtcAck
                           2284 ;	-----------------------------------------
   079D                    2285 _rtcAck:
                           2286 ;	librtc.c:46: itwocAck();
   079D 02s05r3E           2287 	ljmp	_itwocAck
                           2288 ;------------------------------------------------------------
                           2289 ;Allocation info for local variables in function 'rtcStop'
                           2290 ;------------------------------------------------------------
                           2291 ;	librtc.c:50: void rtcStop()							//stop I2C Communication Prototcol.
                           2292 ;	-----------------------------------------
                           2293 ;	 function rtcStop
                           2294 ;	-----------------------------------------
   07A0                    2295 _rtcStop:
                           2296 ;	librtc.c:52: itwocStop();
   07A0 02s05r2C           2297 	ljmp	_itwocStop
                           2298 ;------------------------------------------------------------
                           2299 ;Allocation info for local variables in function 'rtcReceive'
                           2300 ;------------------------------------------------------------
                           2301 ;	librtc.c:55: unsigned char rtcReceive()						//receive data from RTC.
                           2302 ;	-----------------------------------------
                           2303 ;	 function rtcReceive
                           2304 ;	-----------------------------------------
   07A3                    2305 _rtcReceive:
                           2306 ;	librtc.c:57: return itwocGetByte();
   07A3 02s05r9B           2307 	ljmp	_itwocGetByte
                           2308 ;------------------------------------------------------------
                           2309 ;Allocation info for local variables in function 'rtcNoAck'
                           2310 ;------------------------------------------------------------
                           2311 ;	librtc.c:60: void rtcNoAck()						//no Acknowledgement...
                           2312 ;	-----------------------------------------
                           2313 ;	 function rtcNoAck
                           2314 ;	-----------------------------------------
   07A6                    2315 _rtcNoAck:
                           2316 ;	librtc.c:62: itwocNoAck();
   07A6 02s05r49           2317 	ljmp	_itwocNoAck
                           2318 ;------------------------------------------------------------
                           2319 ;Allocation info for local variables in function 'iicClock'
                           2320 ;------------------------------------------------------------
                           2321 ;	librtc.c:65: void iicClock()						//clock for i2c protocol...
                           2322 ;	-----------------------------------------
                           2323 ;	 function iicClock
                           2324 ;	-----------------------------------------
   07A9                    2325 _iicClock:
                           2326 ;	librtc.c:67: itwocClock();
   07A9 02s05r54           2327 	ljmp	_itwocClock
                           2328 ;------------------------------------------------------------
                           2329 ;Allocation info for local variables in function 'iicDelay'
                           2330 ;------------------------------------------------------------
                           2331 ;	librtc.c:70: void iicDelay()						//clock delay method...
                           2332 ;	-----------------------------------------
                           2333 ;	 function iicDelay
                           2334 ;	-----------------------------------------
   07AC                    2335 _iicDelay:
                           2336 ;	librtc.c:72: itwocDelay();
   07AC 02s05rC6           2337 	ljmp	_itwocDelay
                           2338 ;------------------------------------------------------------
                           2339 ;Allocation info for local variables in function 'RTC_get'
                           2340 ;------------------------------------------------------------
                           2341 ;addr                      Allocated to registers r7 
                           2342 ;ret                       Allocated to registers r7 
                           2343 ;------------------------------------------------------------
                           2344 ;	librtc.c:74: unsigned char RTC_get(unsigned char addr)
                           2345 ;	-----------------------------------------
                           2346 ;	 function RTC_get
                           2347 ;	-----------------------------------------
   07AF                    2348 _RTC_get:
   07AF AF 82              2349 	mov	r7,dpl
                           2350 ;	librtc.c:80: startRtc();            /* Start i2c bus */
   07B1 C0 07              2351 	push	ar7
   07B3 12s07r97           2352 	lcall	_startRtc
                           2353 ;	librtc.c:82: rtcSendData(RTC1307);   /* Connect to DS1307 */
   07B6 75 82 D0           2354 	mov	dpl,#0xD0
   07B9 12s07r9A           2355 	lcall	_rtcSendData
   07BC D0 07              2356 	pop	ar7
                           2357 ;	librtc.c:84: rtcSendData(addr); /* Request RAM address on DS1307 */
   07BE 8F 82              2358 	mov	dpl,r7
   07C0 12s07r9A           2359 	lcall	_rtcSendData
                           2360 ;	librtc.c:85: rtcAck();
   07C3 12s07r9D           2361 	lcall	_rtcAck
                           2362 ;	librtc.c:88: startRtc(); /* Start i2c bus */
   07C6 12s07r97           2363 	lcall	_startRtc
                           2364 ;	librtc.c:90: rtcSendData(RTC1307+1); /* Connect to DS1307 for Read */
   07C9 75 82 D1           2365 	mov	dpl,#0xD1
   07CC 12s07r9A           2366 	lcall	_rtcSendData
                           2367 ;	librtc.c:92: ret = rtcReceive(); /* Receive data */
   07CF 12s07rA3           2368 	lcall	_rtcReceive
   07D2 AF 82              2369 	mov	r7,dpl
                           2370 ;	librtc.c:94: rtcNoAck();
   07D4 C0 07              2371 	push	ar7
   07D6 12s07rA6           2372 	lcall	_rtcNoAck
                           2373 ;	librtc.c:95: rtcStop(); /* Stop i2c bus */
   07D9 12s07rA0           2374 	lcall	_rtcStop
   07DC D0 07              2375 	pop	ar7
                           2376 ;	librtc.c:97: return ret; 
   07DE 8F 82              2377 	mov	dpl,r7
   07E0 22                 2378 	ret
                           2379 ;------------------------------------------------------------
                           2380 ;Allocation info for local variables in function 'RTC_settime'
                           2381 ;------------------------------------------------------------
                           2382 ;mm                        Allocated with name '_RTC_settime_PARM_2'
                           2383 ;hh                        Allocated to registers r7 
                           2384 ;------------------------------------------------------------
                           2385 ;	librtc.c:101: void RTC_settime(unsigned char hh, unsigned char mm)
                           2386 ;	-----------------------------------------
                           2387 ;	 function RTC_settime
                           2388 ;	-----------------------------------------
   07E1                    2389 _RTC_settime:
   07E1 AF 82              2390 	mov	r7,dpl
                           2391 ;	librtc.c:104: startRtc();
   07E3 C0 07              2392 	push	ar7
   07E5 12s07r97           2393 	lcall	_startRtc
                           2394 ;	librtc.c:105: rtcSendData(RTC1307); /* connect to DS1307 */
   07E8 75 82 D0           2395 	mov	dpl,#0xD0
   07EB 12s07r9A           2396 	lcall	_rtcSendData
                           2397 ;	librtc.c:106: rtcAck();
   07EE 12s07r9D           2398 	lcall	_rtcAck
                           2399 ;	librtc.c:107: rtcSendData( 0x00 ); /* Request RAM address at 00H */
   07F1 75 82 00           2400 	mov	dpl,#0x00
   07F4 12s07r9A           2401 	lcall	_rtcSendData
                           2402 ;	librtc.c:108: rtcAck();
   07F7 12s07r9D           2403 	lcall	_rtcAck
                           2404 ;	librtc.c:109: rtcSendData( 0x00 ); /* Request RAM address at 00H */
   07FA 75 82 00           2405 	mov	dpl,#0x00
   07FD 12s07r9A           2406 	lcall	_rtcSendData
                           2407 ;	librtc.c:110: rtcNoAck();
   0800 12s07rA6           2408 	lcall	_rtcNoAck
                           2409 ;	librtc.c:111: rtcStop();
   0803 12s07rA0           2410 	lcall	_rtcStop
                           2411 ;	librtc.c:113: startRtc();
   0806 12s07r97           2412 	lcall	_startRtc
                           2413 ;	librtc.c:114: rtcSendData(RTC1307); /* connect to DS1307 */
   0809 75 82 D0           2414 	mov	dpl,#0xD0
   080C 12s07r9A           2415 	lcall	_rtcSendData
                           2416 ;	librtc.c:115: rtcSendData( MIN );
   080F 75 82 01           2417 	mov	dpl,#0x01
   0812 12s07r9A           2418 	lcall	_rtcSendData
                           2419 ;	librtc.c:116: rtcAck();		 
   0815 12s07r9D           2420 	lcall	_rtcAck
                           2421 ;	librtc.c:117: rtcSendData( mm ); /* Write on RAM address 00H */
   0818 85*13 82           2422 	mov	dpl,_RTC_settime_PARM_2
   081B 12s07r9A           2423 	lcall	_rtcSendData
                           2424 ;	librtc.c:118: rtcNoAck();
   081E 12s07rA6           2425 	lcall	_rtcNoAck
                           2426 ;	librtc.c:119: rtcStop();
   0821 12s07rA0           2427 	lcall	_rtcStop
                           2428 ;	librtc.c:121: startRtc();
   0824 12s07r97           2429 	lcall	_startRtc
                           2430 ;	librtc.c:122: rtcSendData(RTC1307); /* connect to DS1307 */
   0827 75 82 D0           2431 	mov	dpl,#0xD0
   082A 12s07r9A           2432 	lcall	_rtcSendData
                           2433 ;	librtc.c:123: rtcSendData( HOUR );
   082D 75 82 02           2434 	mov	dpl,#0x02
   0830 12s07r9A           2435 	lcall	_rtcSendData
                           2436 ;	librtc.c:124: rtcAck();		 
   0833 12s07r9D           2437 	lcall	_rtcAck
   0836 D0 07              2438 	pop	ar7
                           2439 ;	librtc.c:125: rtcSendData( hh ); /* Write on RAM address 00H */
   0838 8F 82              2440 	mov	dpl,r7
   083A 12s07r9A           2441 	lcall	_rtcSendData
                           2442 ;	librtc.c:126: rtcNoAck();
   083D 12s07rA6           2443 	lcall	_rtcNoAck
                           2444 ;	librtc.c:127: rtcStop();
   0840 02s07rA0           2445 	ljmp	_rtcStop
                           2446 ;------------------------------------------------------------
                           2447 ;Allocation info for local variables in function 'RTC_setdate'
                           2448 ;------------------------------------------------------------
                           2449 ;mm                        Allocated with name '_RTC_setdate_PARM_2'
                           2450 ;yy                        Allocated with name '_RTC_setdate_PARM_3'
                           2451 ;dd                        Allocated to registers r7 
                           2452 ;------------------------------------------------------------
                           2453 ;	librtc.c:131: void RTC_setdate(unsigned char dd, unsigned char mm, unsigned char yy)
                           2454 ;	-----------------------------------------
                           2455 ;	 function RTC_setdate
                           2456 ;	-----------------------------------------
   0843                    2457 _RTC_setdate:
   0843 AF 82              2458 	mov	r7,dpl
                           2459 ;	librtc.c:135: startRtc(); 
   0845 C0 07              2460 	push	ar7
   0847 12s07r97           2461 	lcall	_startRtc
                           2462 ;	librtc.c:136: rtcSendData(RTC1307); /* connect to DS1307 */
   084A 75 82 D0           2463 	mov	dpl,#0xD0
   084D 12s07r9A           2464 	lcall	_rtcSendData
                           2465 ;	librtc.c:137: rtcAck();
   0850 12s07r9D           2466 	lcall	_rtcAck
                           2467 ;	librtc.c:138: rtcSendData(0x04); /* Request RAM address at 04H for Date*/
   0853 75 82 04           2468 	mov	dpl,#0x04
   0856 12s07r9A           2469 	lcall	_rtcSendData
                           2470 ;	librtc.c:139: rtcAck();
   0859 12s07r9D           2471 	lcall	_rtcAck
   085C D0 07              2472 	pop	ar7
                           2473 ;	librtc.c:140: rtcSendData(dd); /* Write date on RAM address 04H */
   085E 8F 82              2474 	mov	dpl,r7
   0860 12s07r9A           2475 	lcall	_rtcSendData
                           2476 ;	librtc.c:141: rtcNoAck();
   0863 12s07rA6           2477 	lcall	_rtcNoAck
                           2478 ;	librtc.c:142: rtcStop();
   0866 12s07rA0           2479 	lcall	_rtcStop
                           2480 ;	librtc.c:145: startRtc(); 
   0869 12s07r97           2481 	lcall	_startRtc
                           2482 ;	librtc.c:146: rtcSendData(RTC1307); /* connect to DS1307 */
   086C 75 82 D0           2483 	mov	dpl,#0xD0
   086F 12s07r9A           2484 	lcall	_rtcSendData
                           2485 ;	librtc.c:147: rtcAck();
   0872 12s07r9D           2486 	lcall	_rtcAck
                           2487 ;	librtc.c:148: rtcSendData(0x05); /* Request RAM address at 04H for Date*/
   0875 75 82 05           2488 	mov	dpl,#0x05
   0878 12s07r9A           2489 	lcall	_rtcSendData
                           2490 ;	librtc.c:149: rtcAck();
   087B 12s07r9D           2491 	lcall	_rtcAck
                           2492 ;	librtc.c:150: rtcSendData(mm); /* Write month on RAM address 05H */
   087E 85*14 82           2493 	mov	dpl,_RTC_setdate_PARM_2
   0881 12s07r9A           2494 	lcall	_rtcSendData
                           2495 ;	librtc.c:151: rtcNoAck();
   0884 12s07rA6           2496 	lcall	_rtcNoAck
                           2497 ;	librtc.c:152: rtcStop();
   0887 12s07rA0           2498 	lcall	_rtcStop
                           2499 ;	librtc.c:154: startRtc(); 
   088A 12s07r97           2500 	lcall	_startRtc
                           2501 ;	librtc.c:155: rtcSendData(RTC1307); /* connect to DS1307 */
   088D 75 82 D0           2502 	mov	dpl,#0xD0
   0890 12s07r9A           2503 	lcall	_rtcSendData
                           2504 ;	librtc.c:156: rtcAck();
   0893 12s07r9D           2505 	lcall	_rtcAck
                           2506 ;	librtc.c:157: rtcSendData(0x06); /* Request RAM address at 04H for Date*/
   0896 75 82 06           2507 	mov	dpl,#0x06
   0899 12s07r9A           2508 	lcall	_rtcSendData
                           2509 ;	librtc.c:158: rtcAck();
   089C 12s07r9D           2510 	lcall	_rtcAck
                           2511 ;	librtc.c:159: rtcSendData(yy); /* Write year on RAM address 06H */
   089F 85*15 82           2512 	mov	dpl,_RTC_setdate_PARM_3
   08A2 12s07r9A           2513 	lcall	_rtcSendData
                           2514 ;	librtc.c:160: rtcNoAck();
   08A5 12s07rA6           2515 	lcall	_rtcNoAck
                           2516 ;	librtc.c:161: rtcStop();
   08A8 02s07rA0           2517 	ljmp	_rtcStop
                           2518 ;------------------------------------------------------------
                           2519 ;Allocation info for local variables in function 'RTC_sendToDisplay'
                           2520 ;------------------------------------------------------------
                           2521 ;value                     Allocated to registers r7 
                           2522 ;buf                       Allocated to registers r6 
                           2523 ;------------------------------------------------------------
                           2524 ;	librtc.c:165: void RTC_sendToDisplay(unsigned char value)	//convert BCD to HEX equivalent of ASCII values...
                           2525 ;	-----------------------------------------
                           2526 ;	 function RTC_sendToDisplay
                           2527 ;	-----------------------------------------
   08AB                    2528 _RTC_sendToDisplay:
   08AB AF 82              2529 	mov	r7,dpl
                           2530 ;	librtc.c:169: buf = value & 0xF0; /* Filter for high byte */
   08AD 74 F0              2531 	mov	a,#0xF0
   08AF 5F                 2532 	anl	a,r7
                           2533 ;	librtc.c:171: buf = (buf>>4)|(0x30); /* Convert  to ascii code */
   08B0 C4                 2534 	swap	a
   08B1 54 0F              2535 	anl	a,#0x0F
   08B3 FD                 2536 	mov	r5,a
   08B4 74 30              2537 	mov	a,#0x30
   08B6 4D                 2538 	orl	a,r5
                           2539 ;	librtc.c:173: displayCharLcd(buf); /* Show on LCD */
   08B7 F5 82              2540 	mov	dpl,a
   08B9 C0 07              2541 	push	ar7
   08BB 12s01r63           2542 	lcall	_displayCharLcd
   08BE D0 07              2543 	pop	ar7
                           2544 ;	librtc.c:175: buf = value & 0x0F; /* Filter for low byte */
   08C0 74 0F              2545 	mov	a,#0x0F
   08C2 5F                 2546 	anl	a,r7
   08C3 FE                 2547 	mov	r6,a
                           2548 ;	librtc.c:177: buf = buf | (0x30);        /* Convert to ascii code */
   08C4 43 06 30           2549 	orl	ar6,#0x30
                           2550 ;	librtc.c:179: displayCharLcd(buf); /* Show on LCD */
   08C7 8E 82              2551 	mov	dpl,r6
                           2552 ;	librtc.c:180: return;	
   08C9 02s01r63           2553 	ljmp	_displayCharLcd
                           2554 ;------------------------------------------------------------
                           2555 ;Allocation info for local variables in function 'showScreenKeypad'
                           2556 ;------------------------------------------------------------
                           2557 ;	onscreenkeypad.c:17: void showScreenKeypad()					//brings up the screen keypad on particular area of the screen of 20x4 screen specificly.
                           2558 ;	-----------------------------------------
                           2559 ;	 function showScreenKeypad
                           2560 ;	-----------------------------------------
   08CC                    2561 _showScreenKeypad:
                           2562 ;	onscreenkeypad.c:19: setCursorLcd(0, 0);
   08CC E4                 2563 	clr	a
   08CD F5*06              2564 	mov	_setCursorLcd_PARM_2,a
   08CF F5*07              2565 	mov	(_setCursorLcd_PARM_2 + 1),a
   08D1 F5 82              2566 	mov	dpl,a
   08D3 F5 83              2567 	mov	dph,a
   08D5 12s02r10           2568 	lcall	_setCursorLcd
                           2569 ;	onscreenkeypad.c:20: displayCharLcd( '>' );				// '>'							
   08D8 75 82 3E           2570 	mov	dpl,#0x3E
   08DB 12s01r63           2571 	lcall	_displayCharLcd
                           2572 ;	onscreenkeypad.c:22: setCursorLcd(0, 1);
   08DE 75*06 01           2573 	mov	_setCursorLcd_PARM_2,#0x01
   08E1 75*07 00           2574 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   08E4 90 00 00           2575 	mov	dptr,#0x0000
   08E7 12s02r10           2576 	lcall	_setCursorLcd
                           2577 ;	onscreenkeypad.c:23: displayCharLcd( '0' );	
   08EA 75 82 30           2578 	mov	dpl,#0x30
   08ED 12s01r63           2579 	lcall	_displayCharLcd
                           2580 ;	onscreenkeypad.c:25: setCursorLcd(0, 2);
   08F0 75*06 02           2581 	mov	_setCursorLcd_PARM_2,#0x02
   08F3 75*07 00           2582 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   08F6 90 00 00           2583 	mov	dptr,#0x0000
   08F9 12s02r10           2584 	lcall	_setCursorLcd
                           2585 ;	onscreenkeypad.c:26: displayCharLcd( 'x' );	
   08FC 75 82 78           2586 	mov	dpl,#0x78
   08FF 12s01r63           2587 	lcall	_displayCharLcd
                           2588 ;	onscreenkeypad.c:28: setCursorLcd(0, 3);
   0902 75*06 03           2589 	mov	_setCursorLcd_PARM_2,#0x03
   0905 75*07 00           2590 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   0908 90 00 00           2591 	mov	dptr,#0x0000
   090B 12s02r10           2592 	lcall	_setCursorLcd
                           2593 ;	onscreenkeypad.c:29: displayCharLcd( '^' );			//up Arrow...
   090E 75 82 5E           2594 	mov	dpl,#0x5E
   0911 12s01r63           2595 	lcall	_displayCharLcd
                           2596 ;	onscreenkeypad.c:31: setCursorLcd(1, 0);
   0914 E4                 2597 	clr	a
   0915 F5*06              2598 	mov	_setCursorLcd_PARM_2,a
   0917 F5*07              2599 	mov	(_setCursorLcd_PARM_2 + 1),a
   0919 90 00 01           2600 	mov	dptr,#0x0001
   091C 12s02r10           2601 	lcall	_setCursorLcd
                           2602 ;	onscreenkeypad.c:32: displayCharLcd( '1' );
   091F 75 82 31           2603 	mov	dpl,#0x31
   0922 12s01r63           2604 	lcall	_displayCharLcd
                           2605 ;	onscreenkeypad.c:34: setCursorLcd(1, 1);
   0925 75*06 01           2606 	mov	_setCursorLcd_PARM_2,#0x01
   0928 75*07 00           2607 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   092B 90 00 01           2608 	mov	dptr,#0x0001
   092E 12s02r10           2609 	lcall	_setCursorLcd
                           2610 ;	onscreenkeypad.c:35: displayCharLcd( '2' );
   0931 75 82 32           2611 	mov	dpl,#0x32
   0934 12s01r63           2612 	lcall	_displayCharLcd
                           2613 ;	onscreenkeypad.c:37: setCursorLcd(1, 2);
   0937 75*06 02           2614 	mov	_setCursorLcd_PARM_2,#0x02
   093A 75*07 00           2615 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   093D 90 00 01           2616 	mov	dptr,#0x0001
   0940 12s02r10           2617 	lcall	_setCursorLcd
                           2618 ;	onscreenkeypad.c:38: displayCharLcd( '3' );
   0943 75 82 33           2619 	mov	dpl,#0x33
   0946 12s01r63           2620 	lcall	_displayCharLcd
                           2621 ;	onscreenkeypad.c:40: setCursorLcd(1, 3);
   0949 75*06 03           2622 	mov	_setCursorLcd_PARM_2,#0x03
   094C 75*07 00           2623 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   094F 90 00 01           2624 	mov	dptr,#0x0001
   0952 12s02r10           2625 	lcall	_setCursorLcd
                           2626 ;	onscreenkeypad.c:41: displayCharLcd( 'v' );		//down Arrow
   0955 75 82 76           2627 	mov	dpl,#0x76
   0958 12s01r63           2628 	lcall	_displayCharLcd
                           2629 ;	onscreenkeypad.c:43: setCursorLcd( 2, 0);
   095B E4                 2630 	clr	a
   095C F5*06              2631 	mov	_setCursorLcd_PARM_2,a
   095E F5*07              2632 	mov	(_setCursorLcd_PARM_2 + 1),a
   0960 90 00 02           2633 	mov	dptr,#0x0002
   0963 12s02r10           2634 	lcall	_setCursorLcd
                           2635 ;	onscreenkeypad.c:44: displayCharLcd( '4' );
   0966 75 82 34           2636 	mov	dpl,#0x34
   0969 12s01r63           2637 	lcall	_displayCharLcd
                           2638 ;	onscreenkeypad.c:46: setCursorLcd( 2, 1);
   096C 75*06 01           2639 	mov	_setCursorLcd_PARM_2,#0x01
   096F 75*07 00           2640 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   0972 90 00 02           2641 	mov	dptr,#0x0002
   0975 12s02r10           2642 	lcall	_setCursorLcd
                           2643 ;	onscreenkeypad.c:47: displayCharLcd( '5' );
   0978 75 82 35           2644 	mov	dpl,#0x35
   097B 12s01r63           2645 	lcall	_displayCharLcd
                           2646 ;	onscreenkeypad.c:49: setCursorLcd( 2, 2);
   097E 75*06 02           2647 	mov	_setCursorLcd_PARM_2,#0x02
   0981 75*07 00           2648 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   0984 90 00 02           2649 	mov	dptr,#0x0002
   0987 12s02r10           2650 	lcall	_setCursorLcd
                           2651 ;	onscreenkeypad.c:50: displayCharLcd( '6' );
   098A 75 82 36           2652 	mov	dpl,#0x36
   098D 12s01r63           2653 	lcall	_displayCharLcd
                           2654 ;	onscreenkeypad.c:52: setCursorLcd( 2, 3);
   0990 75*06 03           2655 	mov	_setCursorLcd_PARM_2,#0x03
   0993 75*07 00           2656 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   0996 90 00 02           2657 	mov	dptr,#0x0002
   0999 12s02r10           2658 	lcall	_setCursorLcd
                           2659 ;	onscreenkeypad.c:53: displayCharLcd( 0x7e );		// '->'
   099C 75 82 7E           2660 	mov	dpl,#0x7E
   099F 12s01r63           2661 	lcall	_displayCharLcd
                           2662 ;	onscreenkeypad.c:55: setCursorLcd(3, 0);
   09A2 E4                 2663 	clr	a
   09A3 F5*06              2664 	mov	_setCursorLcd_PARM_2,a
   09A5 F5*07              2665 	mov	(_setCursorLcd_PARM_2 + 1),a
   09A7 90 00 03           2666 	mov	dptr,#0x0003
   09AA 12s02r10           2667 	lcall	_setCursorLcd
                           2668 ;	onscreenkeypad.c:56: displayCharLcd( '7' );
   09AD 75 82 37           2669 	mov	dpl,#0x37
   09B0 12s01r63           2670 	lcall	_displayCharLcd
                           2671 ;	onscreenkeypad.c:58: setCursorLcd( 3, 1);
   09B3 75*06 01           2672 	mov	_setCursorLcd_PARM_2,#0x01
   09B6 75*07 00           2673 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   09B9 90 00 03           2674 	mov	dptr,#0x0003
   09BC 12s02r10           2675 	lcall	_setCursorLcd
                           2676 ;	onscreenkeypad.c:59: displayCharLcd( '8' );
   09BF 75 82 38           2677 	mov	dpl,#0x38
   09C2 12s01r63           2678 	lcall	_displayCharLcd
                           2679 ;	onscreenkeypad.c:61: setCursorLcd( 3,2 );
   09C5 75*06 02           2680 	mov	_setCursorLcd_PARM_2,#0x02
   09C8 75*07 00           2681 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   09CB 90 00 03           2682 	mov	dptr,#0x0003
   09CE 12s02r10           2683 	lcall	_setCursorLcd
                           2684 ;	onscreenkeypad.c:62: displayCharLcd( '9' );
   09D1 75 82 39           2685 	mov	dpl,#0x39
   09D4 12s01r63           2686 	lcall	_displayCharLcd
                           2687 ;	onscreenkeypad.c:64: setCursorLcd( 3, 3);
   09D7 75*06 03           2688 	mov	_setCursorLcd_PARM_2,#0x03
   09DA 75*07 00           2689 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   09DD 90 00 03           2690 	mov	dptr,#0x0003
   09E0 12s02r10           2691 	lcall	_setCursorLcd
                           2692 ;	onscreenkeypad.c:65: displayCharLcd( 0x7f );		//'<-' 
   09E3 75 82 7F           2693 	mov	dpl,#0x7F
   09E6 02s01r63           2694 	ljmp	_displayCharLcd
                           2695 ;------------------------------------------------------------
                           2696 ;Allocation info for local variables in function 'handleScreenKeypadLoop'
                           2697 ;------------------------------------------------------------
                           2698 ;kCode                     Allocated to registers r7 
                           2699 ;kName                     Allocated to registers r7 
                           2700 ;kFlag                     Allocated with name '_handleScreenKeypadLoop_kFlag_1_161'
                           2701 ;nRowIndex                 Allocated to registers r5 r6 
                           2702 ;nColIndex                 Allocated to registers r3 r4 
                           2703 ;nTheVal                   Allocated to registers r1 r2 
                           2704 ;breakpoint                Allocated with name '_handleScreenKeypadLoop_breakpoint_1_161'
                           2705 ;hitCount                  Allocated with name '_handleScreenKeypadLoop_hitCount_1_161'
                           2706 ;cStoreCount               Allocated to registers 
                           2707 ;------------------------------------------------------------
                           2708 ;	onscreenkeypad.c:70: int handleScreenKeypadLoop( )				//routine for onScreenKeypad...
                           2709 ;	-----------------------------------------
                           2710 ;	 function handleScreenKeypadLoop
                           2711 ;	-----------------------------------------
   09E9                    2712 _handleScreenKeypadLoop:
                           2713 ;	onscreenkeypad.c:72: char kCode, kName = 0x00, kFlag = 0x00;
   09E9 75*16 00           2714 	mov	_handleScreenKeypadLoop_kFlag_1_161,#0x00
                           2715 ;	onscreenkeypad.c:73: int nRowIndex = 0;
                           2716 ;	onscreenkeypad.c:74: int	nColIndex = 0;
                           2717 ;	onscreenkeypad.c:75: int nTheVal = 0;
                           2718 ;	onscreenkeypad.c:76: char breakpoint=0;
                           2719 ;	onscreenkeypad.c:77: int hitCount=0, cStoreCount = 0;
   09EC E4                 2720 	clr	a
   09ED FD                 2721 	mov	r5,a
   09EE FE                 2722 	mov	r6,a
   09EF FB                 2723 	mov	r3,a
   09F0 FC                 2724 	mov	r4,a
   09F1 F9                 2725 	mov	r1,a
   09F2 FA                 2726 	mov	r2,a
   09F3 F5*17              2727 	mov	_handleScreenKeypadLoop_breakpoint_1_161,a
   09F5 F5*18              2728 	mov	_handleScreenKeypadLoop_hitCount_1_161,a
   09F7 F5*19              2729 	mov	(_handleScreenKeypadLoop_hitCount_1_161 + 1),a
                           2730 ;	onscreenkeypad.c:79: CursorOn();
   09F9 C0 06              2731 	push	ar6
   09FB C0 05              2732 	push	ar5
   09FD C0 04              2733 	push	ar4
   09FF C0 03              2734 	push	ar3
   0A01 C0 02              2735 	push	ar2
   0A03 C0 01              2736 	push	ar1
   0A05 12s02r7D           2737 	lcall	_CursorOn
                           2738 ;	onscreenkeypad.c:80: BlinkOn();
   0A08 12s02r89           2739 	lcall	_BlinkOn
                           2740 ;	onscreenkeypad.c:82: key_init();
   0A0B 12s00r63           2741 	lcall	_key_init
   0A0E D0 01              2742 	pop	ar1
   0A10 D0 02              2743 	pop	ar2
   0A12 D0 03              2744 	pop	ar3
   0A14 D0 04              2745 	pop	ar4
   0A16 D0 05              2746 	pop	ar5
   0A18 D0 06              2747 	pop	ar6
                           2748 ;	onscreenkeypad.c:85: while( 1 )
   0A1A                    2749 00144$:
                           2750 ;	onscreenkeypad.c:87: kCode = translateKeyCode( get_key() );
   0A1A C0 06              2751 	push	ar6
   0A1C C0 05              2752 	push	ar5
   0A1E C0 04              2753 	push	ar4
   0A20 C0 03              2754 	push	ar3
   0A22 C0 02              2755 	push	ar2
   0A24 C0 01              2756 	push	ar1
   0A26 12s00r67           2757 	lcall	_get_key
   0A29 12s00rC7           2758 	lcall	_translateKeyCode
   0A2C AF 82              2759 	mov	r7,dpl
   0A2E D0 01              2760 	pop	ar1
   0A30 D0 02              2761 	pop	ar2
   0A32 D0 03              2762 	pop	ar3
   0A34 D0 04              2763 	pop	ar4
   0A36 D0 05              2764 	pop	ar5
   0A38 D0 06              2765 	pop	ar6
                           2766 ;	onscreenkeypad.c:88: switch( kCode )
   0A3A BF 33 02           2767 	cjne	r7,#0x33,00190$
   0A3D 80 1A              2768 	sjmp	00101$
   0A3F                    2769 00190$:
   0A3F BF 36 02           2770 	cjne	r7,#0x36,00191$
   0A42 80 6A              2771 	sjmp	00105$
   0A44                    2772 00191$:
   0A44 BF 37 03           2773 	cjne	r7,#0x37,00192$
   0A47 02s0Br02           2774 	ljmp	00109$
   0A4A                    2775 00192$:
   0A4A BF 38 03           2776 	cjne	r7,#0x38,00193$
   0A4D 02s0Cr8A           2777 	ljmp	00132$
   0A50                    2778 00193$:
   0A50 BF 42 03           2779 	cjne	r7,#0x42,00194$
   0A53 02s0CrDF           2780 	ljmp	00136$
   0A56                    2781 00194$:
   0A56 02s0Dr34           2782 	ljmp	00140$
                           2783 ;	onscreenkeypad.c:90: case '3':				//'<-'
   0A59                    2784 00101$:
                           2785 ;	onscreenkeypad.c:91: if( nColIndex == 0)				//if nColIndex == 0 then no change in column.
   0A59 EB                 2786 	mov	a,r3
   0A5A 4C                 2787 	orl	a,r4
                           2788 ;	onscreenkeypad.c:93: setCursorLcd( nRowIndex, 0 );
   0A5B 70 26              2789 	jnz	00103$
   0A5D F5*06              2790 	mov	_setCursorLcd_PARM_2,a
   0A5F F5*07              2791 	mov	(_setCursorLcd_PARM_2 + 1),a
   0A61 8D 82              2792 	mov	dpl,r5
   0A63 8E 83              2793 	mov	dph,r6
   0A65 C0 06              2794 	push	ar6
   0A67 C0 05              2795 	push	ar5
   0A69 C0 04              2796 	push	ar4
   0A6B C0 03              2797 	push	ar3
   0A6D C0 02              2798 	push	ar2
   0A6F C0 01              2799 	push	ar1
   0A71 12s02r10           2800 	lcall	_setCursorLcd
   0A74 D0 01              2801 	pop	ar1
   0A76 D0 02              2802 	pop	ar2
   0A78 D0 03              2803 	pop	ar3
   0A7A D0 04              2804 	pop	ar4
   0A7C D0 05              2805 	pop	ar5
   0A7E D0 06              2806 	pop	ar6
   0A80 02s0Dr34           2807 	ljmp	00140$
   0A83                    2808 00103$:
                           2809 ;	onscreenkeypad.c:97: nColIndex--;				//else change the column and do one minus from it...
   0A83 1B                 2810 	dec	r3
   0A84 BB FF 01           2811 	cjne	r3,#0xFF,00196$
   0A87 1C                 2812 	dec	r4
   0A88                    2813 00196$:
                           2814 ;	onscreenkeypad.c:98: setCursorLcd( nRowIndex, nColIndex);
   0A88 8B*06              2815 	mov	_setCursorLcd_PARM_2,r3
   0A8A 8C*07              2816 	mov	(_setCursorLcd_PARM_2 + 1),r4
   0A8C 8D 82              2817 	mov	dpl,r5
   0A8E 8E 83              2818 	mov	dph,r6
   0A90 C0 06              2819 	push	ar6
   0A92 C0 05              2820 	push	ar5
   0A94 C0 04              2821 	push	ar4
   0A96 C0 03              2822 	push	ar3
   0A98 C0 02              2823 	push	ar2
   0A9A C0 01              2824 	push	ar1
   0A9C 12s02r10           2825 	lcall	_setCursorLcd
   0A9F D0 01              2826 	pop	ar1
   0AA1 D0 02              2827 	pop	ar2
   0AA3 D0 03              2828 	pop	ar3
   0AA5 D0 04              2829 	pop	ar4
   0AA7 D0 05              2830 	pop	ar5
   0AA9 D0 06              2831 	pop	ar6
                           2832 ;	onscreenkeypad.c:100: break;
   0AAB 02s0Dr34           2833 	ljmp	00140$
                           2834 ;	onscreenkeypad.c:102: case '6':				//'^'
   0AAE                    2835 00105$:
                           2836 ;	onscreenkeypad.c:103: if( nRowIndex == 0)				//if nRowIndex == 0 then no change in row.
   0AAE ED                 2837 	mov	a,r5
   0AAF 4E                 2838 	orl	a,r6
   0AB0 70 25              2839 	jnz	00107$
                           2840 ;	onscreenkeypad.c:105: setCursorLcd( 0, nColIndex);
   0AB2 8B*06              2841 	mov	_setCursorLcd_PARM_2,r3
   0AB4 8C*07              2842 	mov	(_setCursorLcd_PARM_2 + 1),r4
   0AB6 90 00 00           2843 	mov	dptr,#0x0000
   0AB9 C0 06              2844 	push	ar6
   0ABB C0 05              2845 	push	ar5
   0ABD C0 04              2846 	push	ar4
   0ABF C0 03              2847 	push	ar3
   0AC1 C0 02              2848 	push	ar2
   0AC3 C0 01              2849 	push	ar1
   0AC5 12s02r10           2850 	lcall	_setCursorLcd
   0AC8 D0 01              2851 	pop	ar1
   0ACA D0 02              2852 	pop	ar2
   0ACC D0 03              2853 	pop	ar3
   0ACE D0 04              2854 	pop	ar4
   0AD0 D0 05              2855 	pop	ar5
   0AD2 D0 06              2856 	pop	ar6
   0AD4 02s0Dr34           2857 	ljmp	00140$
   0AD7                    2858 00107$:
                           2859 ;	onscreenkeypad.c:109: nRowIndex--;				//else change the nRowIndex and do one minus from it...
   0AD7 1D                 2860 	dec	r5
   0AD8 BD FF 01           2861 	cjne	r5,#0xFF,00198$
   0ADB 1E                 2862 	dec	r6
   0ADC                    2863 00198$:
                           2864 ;	onscreenkeypad.c:110: setCursorLcd( nRowIndex, nColIndex);
   0ADC 8B*06              2865 	mov	_setCursorLcd_PARM_2,r3
   0ADE 8C*07              2866 	mov	(_setCursorLcd_PARM_2 + 1),r4
   0AE0 8D 82              2867 	mov	dpl,r5
   0AE2 8E 83              2868 	mov	dph,r6
   0AE4 C0 06              2869 	push	ar6
   0AE6 C0 05              2870 	push	ar5
   0AE8 C0 04              2871 	push	ar4
   0AEA C0 03              2872 	push	ar3
   0AEC C0 02              2873 	push	ar2
   0AEE C0 01              2874 	push	ar1
   0AF0 12s02r10           2875 	lcall	_setCursorLcd
   0AF3 D0 01              2876 	pop	ar1
   0AF5 D0 02              2877 	pop	ar2
   0AF7 D0 03              2878 	pop	ar3
   0AF9 D0 04              2879 	pop	ar4
   0AFB D0 05              2880 	pop	ar5
   0AFD D0 06              2881 	pop	ar6
                           2882 ;	onscreenkeypad.c:112: break;
   0AFF 02s0Dr34           2883 	ljmp	00140$
                           2884 ;	onscreenkeypad.c:114: case '7':				//'[]'
   0B02                    2885 00109$:
                           2886 ;	onscreenkeypad.c:117: kName = getKeyHit( nRowIndex, nColIndex);
   0B02 8B*1A              2887 	mov	_getKeyHit_PARM_2,r3
   0B04 8C*1B              2888 	mov	(_getKeyHit_PARM_2 + 1),r4
   0B06 8D 82              2889 	mov	dpl,r5
   0B08 8E 83              2890 	mov	dph,r6
   0B0A C0 06              2891 	push	ar6
   0B0C C0 05              2892 	push	ar5
   0B0E C0 04              2893 	push	ar4
   0B10 C0 03              2894 	push	ar3
   0B12 C0 02              2895 	push	ar2
   0B14 C0 01              2896 	push	ar1
   0B16 12s0Dr43           2897 	lcall	_getKeyHit
   0B19 AF 82              2898 	mov	r7,dpl
   0B1B D0 01              2899 	pop	ar1
   0B1D D0 02              2900 	pop	ar2
   0B1F D0 03              2901 	pop	ar3
   0B21 D0 04              2902 	pop	ar4
   0B23 D0 05              2903 	pop	ar5
   0B25 D0 06              2904 	pop	ar6
                           2905 ;	onscreenkeypad.c:119: if( nRowIndex == 0 &&  nColIndex == 0)
   0B27 ED                 2906 	mov	a,r5
   0B28 4E                 2907 	orl	a,r6
   0B29 70 2A              2908 	jnz	00129$
   0B2B EB                 2909 	mov	a,r3
   0B2C 4C                 2910 	orl	a,r4
   0B2D 70 26              2911 	jnz	00129$
                           2912 ;	onscreenkeypad.c:122: nTheVal = ReadValueFrom( 3, hitCount);
   0B2F 85*18*08           2913 	mov	_ReadValueFrom_PARM_2,_handleScreenKeypadLoop_hitCount_1_161
   0B32 85*19*09           2914 	mov	(_ReadValueFrom_PARM_2 + 1),(_handleScreenKeypadLoop_hitCount_1_161 + 1)
   0B35 90 00 03           2915 	mov	dptr,#0x0003
   0B38 C0 06              2916 	push	ar6
   0B3A C0 05              2917 	push	ar5
   0B3C C0 04              2918 	push	ar4
   0B3E C0 03              2919 	push	ar3
   0B40 12s02rDE           2920 	lcall	_ReadValueFrom
   0B43 A9 82              2921 	mov	r1,dpl
   0B45 AA 83              2922 	mov	r2,dph
   0B47 D0 03              2923 	pop	ar3
   0B49 D0 04              2924 	pop	ar4
   0B4B D0 05              2925 	pop	ar5
   0B4D D0 06              2926 	pop	ar6
                           2927 ;	onscreenkeypad.c:123: breakpoint = 1;					
   0B4F 75*17 01           2928 	mov	_handleScreenKeypadLoop_breakpoint_1_161,#0x01
   0B52 02s0Cr64           2929 	ljmp	00130$
   0B55                    2930 00129$:
                           2931 ;	onscreenkeypad.c:125: else if( nRowIndex == 2 &&  nColIndex == 3 )
   0B55 BD 02 65           2932 	cjne	r5,#0x02,00125$
   0B58 BE 00 62           2933 	cjne	r6,#0x00,00125$
   0B5B BB 03 5F           2934 	cjne	r3,#0x03,00125$
   0B5E BC 00 5C           2935 	cjne	r4,#0x00,00125$
                           2936 ;	onscreenkeypad.c:127: if( kFlag == 0x01 )
   0B61 74 01              2937 	mov	a,#0x01
   0B63 B5*16 31           2938 	cjne	a,_handleScreenKeypadLoop_kFlag_1_161,00111$
                           2939 ;	onscreenkeypad.c:129: hitCount++;		
   0B66 05*18              2940 	inc	_handleScreenKeypadLoop_hitCount_1_161
   0B68 E4                 2941 	clr	a
   0B69 B5*18 02           2942 	cjne	a,_handleScreenKeypadLoop_hitCount_1_161,00207$
   0B6C 05*19              2943 	inc	(_handleScreenKeypadLoop_hitCount_1_161 + 1)
   0B6E                    2944 00207$:
                           2945 ;	onscreenkeypad.c:130: kFlag = 0x00;
   0B6E 75*16 00           2946 	mov	_handleScreenKeypadLoop_kFlag_1_161,#0x00
                           2947 ;	onscreenkeypad.c:132: setCursorLcd( nRowIndex, nColIndex);
   0B71 8B*06              2948 	mov	_setCursorLcd_PARM_2,r3
   0B73 8C*07              2949 	mov	(_setCursorLcd_PARM_2 + 1),r4
   0B75 8D 82              2950 	mov	dpl,r5
   0B77 8E 83              2951 	mov	dph,r6
   0B79 C0 06              2952 	push	ar6
   0B7B C0 05              2953 	push	ar5
   0B7D C0 04              2954 	push	ar4
   0B7F C0 03              2955 	push	ar3
   0B81 C0 02              2956 	push	ar2
   0B83 C0 01              2957 	push	ar1
   0B85 12s02r10           2958 	lcall	_setCursorLcd
   0B88 D0 01              2959 	pop	ar1
   0B8A D0 02              2960 	pop	ar2
   0B8C D0 03              2961 	pop	ar3
   0B8E D0 04              2962 	pop	ar4
   0B90 D0 05              2963 	pop	ar5
   0B92 D0 06              2964 	pop	ar6
                           2965 ;	onscreenkeypad.c:133: continue;
   0B94 02s0Ar1A           2966 	ljmp	00144$
   0B97                    2967 00111$:
                           2968 ;	onscreenkeypad.c:137: setCursorLcd( nRowIndex, nColIndex);
   0B97 8B*06              2969 	mov	_setCursorLcd_PARM_2,r3
   0B99 8C*07              2970 	mov	(_setCursorLcd_PARM_2 + 1),r4
   0B9B 8D 82              2971 	mov	dpl,r5
   0B9D 8E 83              2972 	mov	dph,r6
   0B9F C0 06              2973 	push	ar6
   0BA1 C0 05              2974 	push	ar5
   0BA3 C0 04              2975 	push	ar4
   0BA5 C0 03              2976 	push	ar3
   0BA7 C0 02              2977 	push	ar2
   0BA9 C0 01              2978 	push	ar1
   0BAB 12s02r10           2979 	lcall	_setCursorLcd
   0BAE D0 01              2980 	pop	ar1
   0BB0 D0 02              2981 	pop	ar2
   0BB2 D0 03              2982 	pop	ar3
   0BB4 D0 04              2983 	pop	ar4
   0BB6 D0 05              2984 	pop	ar5
   0BB8 D0 06              2985 	pop	ar6
                           2986 ;	onscreenkeypad.c:138: continue;
   0BBA 02s0Ar1A           2987 	ljmp	00144$
   0BBD                    2988 00125$:
                           2989 ;	onscreenkeypad.c:141: else if( nRowIndex == 3 &&  nColIndex == 3 ){
   0BBD BD 03 44           2990 	cjne	r5,#0x03,00121$
   0BC0 BE 00 41           2991 	cjne	r6,#0x00,00121$
   0BC3 BB 03 3E           2992 	cjne	r3,#0x03,00121$
   0BC6 BC 00 3B           2993 	cjne	r4,#0x00,00121$
                           2994 ;	onscreenkeypad.c:143: if( hitCount == 0)					
   0BC9 E5*18              2995 	mov	a,_handleScreenKeypadLoop_hitCount_1_161
   0BCB 45*19              2996 	orl	a,(_handleScreenKeypadLoop_hitCount_1_161 + 1)
                           2997 ;	onscreenkeypad.c:144: hitCount=0;
   0BCD 70 06              2998 	jnz	00114$
   0BCF F5*18              2999 	mov	_handleScreenKeypadLoop_hitCount_1_161,a
   0BD1 F5*19              3000 	mov	(_handleScreenKeypadLoop_hitCount_1_161 + 1),a
   0BD3 80 09              3001 	sjmp	00115$
   0BD5                    3002 00114$:
                           3003 ;	onscreenkeypad.c:146: hitCount--;	
   0BD5 15*18              3004 	dec	_handleScreenKeypadLoop_hitCount_1_161
   0BD7 74 FF              3005 	mov	a,#0xFF
   0BD9 B5*18 02           3006 	cjne	a,_handleScreenKeypadLoop_hitCount_1_161,00213$
   0BDC 15*19              3007 	dec	(_handleScreenKeypadLoop_hitCount_1_161 + 1)
   0BDE                    3008 00213$:
   0BDE                    3009 00115$:
                           3010 ;	onscreenkeypad.c:147: setCursorLcd( nRowIndex, nColIndex);
   0BDE 8B*06              3011 	mov	_setCursorLcd_PARM_2,r3
   0BE0 8C*07              3012 	mov	(_setCursorLcd_PARM_2 + 1),r4
   0BE2 8D 82              3013 	mov	dpl,r5
   0BE4 8E 83              3014 	mov	dph,r6
   0BE6 C0 06              3015 	push	ar6
   0BE8 C0 05              3016 	push	ar5
   0BEA C0 04              3017 	push	ar4
   0BEC C0 03              3018 	push	ar3
   0BEE C0 02              3019 	push	ar2
   0BF0 C0 01              3020 	push	ar1
   0BF2 12s02r10           3021 	lcall	_setCursorLcd
   0BF5 D0 01              3022 	pop	ar1
   0BF7 D0 02              3023 	pop	ar2
   0BF9 D0 03              3024 	pop	ar3
   0BFB D0 04              3025 	pop	ar4
   0BFD D0 05              3026 	pop	ar5
   0BFF D0 06              3027 	pop	ar6
                           3028 ;	onscreenkeypad.c:148: continue;
   0C01 02s0Ar1A           3029 	ljmp	00144$
   0C04                    3030 00121$:
                           3031 ;	onscreenkeypad.c:150: else if( nRowIndex == 0 &&  nColIndex == 2 )
   0C04 ED                 3032 	mov	a,r5
   0C05 4E                 3033 	orl	a,r6
   0C06 70 0F              3034 	jnz	00117$
   0C08 BB 02 0C           3035 	cjne	r3,#0x02,00117$
   0C0B BC 00 09           3036 	cjne	r4,#0x00,00117$
                           3037 ;	onscreenkeypad.c:153: nTheVal = 0;
   0C0E 79 00              3038 	mov	r1,#0x00
   0C10 7A 00              3039 	mov	r2,#0x00
                           3040 ;	onscreenkeypad.c:154: breakpoint = 1;
   0C12 75*17 01           3041 	mov	_handleScreenKeypadLoop_breakpoint_1_161,#0x01
   0C15 80 4D              3042 	sjmp	00130$
   0C17                    3043 00117$:
                           3044 ;	onscreenkeypad.c:158: setCursorLcd( 3, 5 + hitCount);
   0C17 74 05              3045 	mov	a,#0x05
   0C19 25*18              3046 	add	a,_handleScreenKeypadLoop_hitCount_1_161
   0C1B F5*06              3047 	mov	_setCursorLcd_PARM_2,a
   0C1D E4                 3048 	clr	a
   0C1E 35*19              3049 	addc	a,(_handleScreenKeypadLoop_hitCount_1_161 + 1)
   0C20 F5*07              3050 	mov	(_setCursorLcd_PARM_2 + 1),a
   0C22 90 00 03           3051 	mov	dptr,#0x0003
   0C25 C0 07              3052 	push	ar7
   0C27 C0 06              3053 	push	ar6
   0C29 C0 05              3054 	push	ar5
   0C2B C0 04              3055 	push	ar4
   0C2D C0 03              3056 	push	ar3
   0C2F C0 02              3057 	push	ar2
   0C31 C0 01              3058 	push	ar1
   0C33 12s02r10           3059 	lcall	_setCursorLcd
   0C36 D0 01              3060 	pop	ar1
   0C38 D0 02              3061 	pop	ar2
   0C3A D0 03              3062 	pop	ar3
   0C3C D0 04              3063 	pop	ar4
   0C3E D0 05              3064 	pop	ar5
   0C40 D0 06              3065 	pop	ar6
   0C42 D0 07              3066 	pop	ar7
                           3067 ;	onscreenkeypad.c:159: displayCharLcd( kName );	
   0C44 8F 82              3068 	mov	dpl,r7
   0C46 C0 06              3069 	push	ar6
   0C48 C0 05              3070 	push	ar5
   0C4A C0 04              3071 	push	ar4
   0C4C C0 03              3072 	push	ar3
   0C4E C0 02              3073 	push	ar2
   0C50 C0 01              3074 	push	ar1
   0C52 12s01r63           3075 	lcall	_displayCharLcd
   0C55 D0 01              3076 	pop	ar1
   0C57 D0 02              3077 	pop	ar2
   0C59 D0 03              3078 	pop	ar3
   0C5B D0 04              3079 	pop	ar4
   0C5D D0 05              3080 	pop	ar5
   0C5F D0 06              3081 	pop	ar6
                           3082 ;	onscreenkeypad.c:160: kFlag = 0x01;
   0C61 75*16 01           3083 	mov	_handleScreenKeypadLoop_kFlag_1_161,#0x01
   0C64                    3084 00130$:
                           3085 ;	onscreenkeypad.c:162: setCursorLcd( nRowIndex, nColIndex );
   0C64 8B*06              3086 	mov	_setCursorLcd_PARM_2,r3
   0C66 8C*07              3087 	mov	(_setCursorLcd_PARM_2 + 1),r4
   0C68 8D 82              3088 	mov	dpl,r5
   0C6A 8E 83              3089 	mov	dph,r6
   0C6C C0 06              3090 	push	ar6
   0C6E C0 05              3091 	push	ar5
   0C70 C0 04              3092 	push	ar4
   0C72 C0 03              3093 	push	ar3
   0C74 C0 02              3094 	push	ar2
   0C76 C0 01              3095 	push	ar1
   0C78 12s02r10           3096 	lcall	_setCursorLcd
   0C7B D0 01              3097 	pop	ar1
   0C7D D0 02              3098 	pop	ar2
   0C7F D0 03              3099 	pop	ar3
   0C81 D0 04              3100 	pop	ar4
   0C83 D0 05              3101 	pop	ar5
   0C85 D0 06              3102 	pop	ar6
                           3103 ;	onscreenkeypad.c:163: break;
   0C87 02s0Dr34           3104 	ljmp	00140$
                           3105 ;	onscreenkeypad.c:165: case '8':				//'v'
   0C8A                    3106 00132$:
                           3107 ;	onscreenkeypad.c:166: if( nRowIndex == 3)				//if nRowIndex == 3 then no change in row.
   0C8A BD 03 28           3108 	cjne	r5,#0x03,00134$
   0C8D BE 00 25           3109 	cjne	r6,#0x00,00134$
                           3110 ;	onscreenkeypad.c:168: setCursorLcd( 3, nColIndex);
   0C90 8B*06              3111 	mov	_setCursorLcd_PARM_2,r3
   0C92 8C*07              3112 	mov	(_setCursorLcd_PARM_2 + 1),r4
   0C94 90 00 03           3113 	mov	dptr,#0x0003
   0C97 C0 06              3114 	push	ar6
   0C99 C0 05              3115 	push	ar5
   0C9B C0 04              3116 	push	ar4
   0C9D C0 03              3117 	push	ar3
   0C9F C0 02              3118 	push	ar2
   0CA1 C0 01              3119 	push	ar1
   0CA3 12s02r10           3120 	lcall	_setCursorLcd
   0CA6 D0 01              3121 	pop	ar1
   0CA8 D0 02              3122 	pop	ar2
   0CAA D0 03              3123 	pop	ar3
   0CAC D0 04              3124 	pop	ar4
   0CAE D0 05              3125 	pop	ar5
   0CB0 D0 06              3126 	pop	ar6
   0CB2 02s0Dr34           3127 	ljmp	00140$
   0CB5                    3128 00134$:
                           3129 ;	onscreenkeypad.c:172: nRowIndex++;				//else change the nRowIndex and do one add to it...
   0CB5 0D                 3130 	inc	r5
   0CB6 BD 00 01           3131 	cjne	r5,#0x00,00219$
   0CB9 0E                 3132 	inc	r6
   0CBA                    3133 00219$:
                           3134 ;	onscreenkeypad.c:173: setCursorLcd( nRowIndex, nColIndex);
   0CBA 8B*06              3135 	mov	_setCursorLcd_PARM_2,r3
   0CBC 8C*07              3136 	mov	(_setCursorLcd_PARM_2 + 1),r4
   0CBE 8D 82              3137 	mov	dpl,r5
   0CC0 8E 83              3138 	mov	dph,r6
   0CC2 C0 06              3139 	push	ar6
   0CC4 C0 05              3140 	push	ar5
   0CC6 C0 04              3141 	push	ar4
   0CC8 C0 03              3142 	push	ar3
   0CCA C0 02              3143 	push	ar2
   0CCC C0 01              3144 	push	ar1
   0CCE 12s02r10           3145 	lcall	_setCursorLcd
   0CD1 D0 01              3146 	pop	ar1
   0CD3 D0 02              3147 	pop	ar2
   0CD5 D0 03              3148 	pop	ar3
   0CD7 D0 04              3149 	pop	ar4
   0CD9 D0 05              3150 	pop	ar5
   0CDB D0 06              3151 	pop	ar6
                           3152 ;	onscreenkeypad.c:175: break;
                           3153 ;	onscreenkeypad.c:177: case 'B':				//'->'
   0CDD 80 55              3154 	sjmp	00140$
   0CDF                    3155 00136$:
                           3156 ;	onscreenkeypad.c:178: if( nColIndex == 3)				//if nColIndex == 3 then no change in column.
   0CDF BB 03 2A           3157 	cjne	r3,#0x03,00138$
   0CE2 BC 00 27           3158 	cjne	r4,#0x00,00138$
                           3159 ;	onscreenkeypad.c:180: setCursorLcd( nRowIndex, 3);
   0CE5 75*06 03           3160 	mov	_setCursorLcd_PARM_2,#0x03
   0CE8 75*07 00           3161 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   0CEB 8D 82              3162 	mov	dpl,r5
   0CED 8E 83              3163 	mov	dph,r6
   0CEF C0 06              3164 	push	ar6
   0CF1 C0 05              3165 	push	ar5
   0CF3 C0 04              3166 	push	ar4
   0CF5 C0 03              3167 	push	ar3
   0CF7 C0 02              3168 	push	ar2
   0CF9 C0 01              3169 	push	ar1
   0CFB 12s02r10           3170 	lcall	_setCursorLcd
   0CFE D0 01              3171 	pop	ar1
   0D00 D0 02              3172 	pop	ar2
   0D02 D0 03              3173 	pop	ar3
   0D04 D0 04              3174 	pop	ar4
   0D06 D0 05              3175 	pop	ar5
   0D08 D0 06              3176 	pop	ar6
   0D0A 80 28              3177 	sjmp	00140$
   0D0C                    3178 00138$:
                           3179 ;	onscreenkeypad.c:184: nColIndex++;				//else change the nColIndex and do one add to it...
   0D0C 0B                 3180 	inc	r3
   0D0D BB 00 01           3181 	cjne	r3,#0x00,00222$
   0D10 0C                 3182 	inc	r4
   0D11                    3183 00222$:
                           3184 ;	onscreenkeypad.c:185: setCursorLcd( nRowIndex, nColIndex);
   0D11 8B*06              3185 	mov	_setCursorLcd_PARM_2,r3
   0D13 8C*07              3186 	mov	(_setCursorLcd_PARM_2 + 1),r4
   0D15 8D 82              3187 	mov	dpl,r5
   0D17 8E 83              3188 	mov	dph,r6
   0D19 C0 06              3189 	push	ar6
   0D1B C0 05              3190 	push	ar5
   0D1D C0 04              3191 	push	ar4
   0D1F C0 03              3192 	push	ar3
   0D21 C0 02              3193 	push	ar2
   0D23 C0 01              3194 	push	ar1
   0D25 12s02r10           3195 	lcall	_setCursorLcd
   0D28 D0 01              3196 	pop	ar1
   0D2A D0 02              3197 	pop	ar2
   0D2C D0 03              3198 	pop	ar3
   0D2E D0 04              3199 	pop	ar4
   0D30 D0 05              3200 	pop	ar5
   0D32 D0 06              3201 	pop	ar6
                           3202 ;	onscreenkeypad.c:189: }
   0D34                    3203 00140$:
                           3204 ;	onscreenkeypad.c:190: if( breakpoint == 1 )
   0D34 74 01              3205 	mov	a,#0x01
   0D36 B5*17 02           3206 	cjne	a,_handleScreenKeypadLoop_breakpoint_1_161,00223$
   0D39 80 03              3207 	sjmp	00224$
   0D3B                    3208 00223$:
   0D3B 02s0Ar1A           3209 	ljmp	00144$
   0D3E                    3210 00224$:
                           3211 ;	onscreenkeypad.c:193: return nTheVal;
   0D3E 89 82              3212 	mov	dpl,r1
   0D40 8A 83              3213 	mov	dph,r2
   0D42 22                 3214 	ret
                           3215 ;------------------------------------------------------------
                           3216 ;Allocation info for local variables in function 'getKeyHit'
                           3217 ;------------------------------------------------------------
                           3218 ;nClm                      Allocated with name '_getKeyHit_PARM_2'
                           3219 ;nRw                       Allocated to registers 
                           3220 ;------------------------------------------------------------
                           3221 ;	onscreenkeypad.c:196: unsigned char getKeyHit(int nRw, int nClm)							//routine for scaning the keey so hit by user on OnScreen KeyPad/KeyBoard.
                           3222 ;	-----------------------------------------
                           3223 ;	 function getKeyHit
                           3224 ;	-----------------------------------------
   0D43                    3225 _getKeyHit:
                           3226 ;	onscreenkeypad.c:198: setCursorLcd( nRw, nClm );
   0D43 85*1A*06           3227 	mov	_setCursorLcd_PARM_2,_getKeyHit_PARM_2
   0D46 85*1B*07           3228 	mov	(_setCursorLcd_PARM_2 + 1),(_getKeyHit_PARM_2 + 1)
   0D49 12s02r10           3229 	lcall	_setCursorLcd
                           3230 ;	onscreenkeypad.c:200: return ReadFromLcd();
   0D4C 02s02r9B           3231 	ljmp	_ReadFromLcd
                           3232 ;------------------------------------------------------------
                           3233 ;Allocation info for local variables in function 'ecs_MainMenu'
                           3234 ;------------------------------------------------------------
                           3235 ;cToCount                  Allocated to registers r7 
                           3236 ;------------------------------------------------------------
                           3237 ;	menuPanel.c:23: void ecs_MainMenu()				//Main Menu for Navigation with options...
                           3238 ;	-----------------------------------------
                           3239 ;	 function ecs_MainMenu
                           3240 ;	-----------------------------------------
   0D4F                    3241 _ecs_MainMenu:
                           3242 ;	menuPanel.c:26: clearLcdScreen();
   0D4F 12s02r68           3243 	lcall	_clearLcdScreen
                           3244 ;	menuPanel.c:27: key_init();
   0D52 12s00r63           3245 	lcall	_key_init
                           3246 ;	menuPanel.c:29: setCursorLcd( 0, 0);
   0D55 E4                 3247 	clr	a
   0D56 F5*06              3248 	mov	_setCursorLcd_PARM_2,a
   0D58 F5*07              3249 	mov	(_setCursorLcd_PARM_2 + 1),a
   0D5A F5 82              3250 	mov	dpl,a
   0D5C F5 83              3251 	mov	dph,a
   0D5E 12s02r10           3252 	lcall	_setCursorLcd
                           3253 ;	menuPanel.c:30: displayStringLcd("ECS");
   0D61 90s00r40           3254 	mov	dptr,#__str_0
   0D64 75 F0 80           3255 	mov	b,#0x80
   0D67 12s01r6B           3256 	lcall	_displayStringLcd
                           3257 ;	menuPanel.c:31: setCursorLcd( 1, 0);
   0D6A E4                 3258 	clr	a
   0D6B F5*06              3259 	mov	_setCursorLcd_PARM_2,a
   0D6D F5*07              3260 	mov	(_setCursorLcd_PARM_2 + 1),a
   0D6F 90 00 01           3261 	mov	dptr,#0x0001
   0D72 12s02r10           3262 	lcall	_setCursorLcd
                           3263 ;	menuPanel.c:32: displayStringLcd("Main");
   0D75 90s00r54           3264 	mov	dptr,#__str_2
   0D78 75 F0 80           3265 	mov	b,#0x80
   0D7B 12s01r6B           3266 	lcall	_displayStringLcd
                           3267 ;	menuPanel.c:33: setCursorLcd( 2, 0);
   0D7E E4                 3268 	clr	a
   0D7F F5*06              3269 	mov	_setCursorLcd_PARM_2,a
   0D81 F5*07              3270 	mov	(_setCursorLcd_PARM_2 + 1),a
   0D83 90 00 02           3271 	mov	dptr,#0x0002
   0D86 12s02r10           3272 	lcall	_setCursorLcd
                           3273 ;	menuPanel.c:34: displayStringLcd("Menu");
   0D89 90s00r59           3274 	mov	dptr,#__str_3
   0D8C 75 F0 80           3275 	mov	b,#0x80
   0D8F 12s01r6B           3276 	lcall	_displayStringLcd
                           3277 ;	menuPanel.c:36: for(cToCount =0;cToCount<3; cToCount++){
   0D92 7F 00              3278 	mov	r7,#0x00
   0D94                    3279 00101$:
   0D94 C3                 3280 	clr	c
   0D95 EF                 3281 	mov	a,r7
   0D96 64 80              3282 	xrl	a,#0x80
   0D98 94 83              3283 	subb	a,#0x83
   0D9A 50 20              3284 	jnc	00104$
                           3285 ;	menuPanel.c:37: setCursorLcd(cToCount, 4);
   0D9C EF                 3286 	mov	a,r7
   0D9D FD                 3287 	mov	r5,a
   0D9E 33                 3288 	rlc	a
   0D9F 95 E0              3289 	subb	a,acc
   0DA1 FE                 3290 	mov	r6,a
   0DA2 75*06 04           3291 	mov	_setCursorLcd_PARM_2,#0x04
   0DA5 75*07 00           3292 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   0DA8 8D 82              3293 	mov	dpl,r5
   0DAA 8E 83              3294 	mov	dph,r6
   0DAC C0 07              3295 	push	ar7
   0DAE 12s02r10           3296 	lcall	_setCursorLcd
                           3297 ;	menuPanel.c:38: displayCharLcd( 4 );		
   0DB1 75 82 04           3298 	mov	dpl,#0x04
   0DB4 12s01r63           3299 	lcall	_displayCharLcd
   0DB7 D0 07              3300 	pop	ar7
                           3301 ;	menuPanel.c:36: for(cToCount =0;cToCount<3; cToCount++){
   0DB9 0F                 3302 	inc	r7
   0DBA 80 D8              3303 	sjmp	00101$
   0DBC                    3304 00104$:
                           3305 ;	menuPanel.c:40: setCursorLcd(0, 5);
   0DBC 75*06 05           3306 	mov	_setCursorLcd_PARM_2,#0x05
   0DBF 75*07 00           3307 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   0DC2 90 00 00           3308 	mov	dptr,#0x0000
   0DC5 12s02r10           3309 	lcall	_setCursorLcd
                           3310 ;	menuPanel.c:41: displayCharLcd( 0x7f);						//box symbol ascii equivalentt hex code...
   0DC8 75 82 7F           3311 	mov	dpl,#0x7F
   0DCB 12s01r63           3312 	lcall	_displayCharLcd
                           3313 ;	menuPanel.c:42: displayStringLcd("Sync Data...");
   0DCE 90s00r5E           3314 	mov	dptr,#__str_4
   0DD1 75 F0 80           3315 	mov	b,#0x80
   0DD4 12s01r6B           3316 	lcall	_displayStringLcd
                           3317 ;	menuPanel.c:44: setCursorLcd( 1, 5 );
   0DD7 75*06 05           3318 	mov	_setCursorLcd_PARM_2,#0x05
   0DDA 75*07 00           3319 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   0DDD 90 00 01           3320 	mov	dptr,#0x0001
   0DE0 12s02r10           3321 	lcall	_setCursorLcd
                           3322 ;	menuPanel.c:45: displayCharLcd( 0xdb );							//symbol for Sync mode operation.'<-'
   0DE3 75 82 DB           3323 	mov	dpl,#0xDB
   0DE6 12s01r63           3324 	lcall	_displayCharLcd
                           3325 ;	menuPanel.c:46: displayStringLcd( "Settings...");
   0DE9 90s00r6B           3326 	mov	dptr,#__str_5
   0DEC 75 F0 80           3327 	mov	b,#0x80
   0DEF 12s01r6B           3328 	lcall	_displayStringLcd
                           3329 ;	menuPanel.c:47: setCursorLcd( 2, 5 );
   0DF2 75*06 05           3330 	mov	_setCursorLcd_PARM_2,#0x05
   0DF5 75*07 00           3331 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   0DF8 90 00 02           3332 	mov	dptr,#0x0002
   0DFB 12s02r10           3333 	lcall	_setCursorLcd
                           3334 ;	menuPanel.c:49: displayCharLcd( 0x7e );							//symbol for Data mode operation. '->'
   0DFE 75 82 7E           3335 	mov	dpl,#0x7E
   0E01 12s01r63           3336 	lcall	_displayCharLcd
                           3337 ;	menuPanel.c:50: displayStringLcd( "Data Entry...");
   0E04 90s00r77           3338 	mov	dptr,#__str_6
   0E07 75 F0 80           3339 	mov	b,#0x80
   0E0A 12s01r6B           3340 	lcall	_displayStringLcd
                           3341 ;	menuPanel.c:52: for(cToCount =0;cToCount<20; cToCount++){
   0E0D 7F 00              3342 	mov	r7,#0x00
   0E0F                    3343 00105$:
   0E0F C3                 3344 	clr	c
   0E10 EF                 3345 	mov	a,r7
   0E11 64 80              3346 	xrl	a,#0x80
   0E13 94 94              3347 	subb	a,#0x94
   0E15 50 1B              3348 	jnc	00108$
                           3349 ;	menuPanel.c:53: setCursorLcd(3, cToCount);
   0E17 EF                 3350 	mov	a,r7
   0E18 F5*06              3351 	mov	_setCursorLcd_PARM_2,a
   0E1A 33                 3352 	rlc	a
   0E1B 95 E0              3353 	subb	a,acc
   0E1D F5*07              3354 	mov	(_setCursorLcd_PARM_2 + 1),a
   0E1F 90 00 03           3355 	mov	dptr,#0x0003
   0E22 C0 07              3356 	push	ar7
   0E24 12s02r10           3357 	lcall	_setCursorLcd
                           3358 ;	menuPanel.c:54: displayCharLcd( 1 );		
   0E27 75 82 01           3359 	mov	dpl,#0x01
   0E2A 12s01r63           3360 	lcall	_displayCharLcd
   0E2D D0 07              3361 	pop	ar7
                           3362 ;	menuPanel.c:52: for(cToCount =0;cToCount<20; cToCount++){
   0E2F 0F                 3363 	inc	r7
   0E30 80 DD              3364 	sjmp	00105$
   0E32                    3365 00108$:
                           3366 ;	menuPanel.c:57: CursorOff();
   0E32 02s02r77           3367 	ljmp	_CursorOff
                           3368 ;------------------------------------------------------------
                           3369 ;Allocation info for local variables in function 'SettingActivity'
                           3370 ;------------------------------------------------------------
                           3371 ;cNCnt                     Allocated to registers r6 
                           3372 ;iLp                       Allocated to registers r6 
                           3373 ;cXVal                     Allocated to registers r7 
                           3374 ;cYVal                     Allocated to registers r6 
                           3375 ;cZVal                     Allocated with name '_SettingActivity_cZVal_1_184'
                           3376 ;cLVal                     Allocated with name '_SettingActivity_cLVal_1_184'
                           3377 ;time                      Allocated with name '_SettingActivity_time_1_184'
                           3378 ;date                      Allocated with name '_SettingActivity_date_1_184'
                           3379 ;ni                        Allocated with name '_SettingActivity_ni_1_184'
                           3380 ;------------------------------------------------------------
                           3381 ;	setting.c:18: void SettingActivity()				//the setting activity panel : ECS
                           3382 ;	-----------------------------------------
                           3383 ;	 function SettingActivity
                           3384 ;	-----------------------------------------
   0E35                    3385 _SettingActivity:
                           3386 ;	setting.c:20: char cNCnt, iLp=0, cXVal = 0x00, cYVal = 0x00, cZVal = 0x00, cLVal = 0x00;	
                           3387 ;	setting.c:22: clearLcdScreen();
   0E35 12s02r68           3388 	lcall	_clearLcdScreen
                           3389 ;	setting.c:24: showScreenKeypad();
   0E38 12s08rCC           3390 	lcall	_showScreenKeypad
                           3391 ;	setting.c:26: for(cNCnt =0;cNCnt<4; cNCnt++){
   0E3B 7E 00              3392 	mov	r6,#0x00
   0E3D                    3393 00122$:
   0E3D C3                 3394 	clr	c
   0E3E EE                 3395 	mov	a,r6
   0E3F 64 80              3396 	xrl	a,#0x80
   0E41 94 84              3397 	subb	a,#0x84
   0E43 50 20              3398 	jnc	00125$
                           3399 ;	setting.c:27: setCursorLcd(cNCnt, 4);
   0E45 EE                 3400 	mov	a,r6
   0E46 FC                 3401 	mov	r4,a
   0E47 33                 3402 	rlc	a
   0E48 95 E0              3403 	subb	a,acc
   0E4A FD                 3404 	mov	r5,a
   0E4B 75*06 04           3405 	mov	_setCursorLcd_PARM_2,#0x04
   0E4E 75*07 00           3406 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   0E51 8C 82              3407 	mov	dpl,r4
   0E53 8D 83              3408 	mov	dph,r5
   0E55 C0 06              3409 	push	ar6
   0E57 12s02r10           3410 	lcall	_setCursorLcd
                           3411 ;	setting.c:28: displayCharLcd( 3 );		
   0E5A 75 82 03           3412 	mov	dpl,#0x03
   0E5D 12s01r63           3413 	lcall	_displayCharLcd
   0E60 D0 06              3414 	pop	ar6
                           3415 ;	setting.c:26: for(cNCnt =0;cNCnt<4; cNCnt++){
   0E62 0E                 3416 	inc	r6
   0E63 80 D8              3417 	sjmp	00122$
   0E65                    3418 00125$:
                           3419 ;	setting.c:31: setCursorLcd( 0, 5);
   0E65 75*06 05           3420 	mov	_setCursorLcd_PARM_2,#0x05
   0E68 75*07 00           3421 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   0E6B 90 00 00           3422 	mov	dptr,#0x0000
   0E6E 12s02r10           3423 	lcall	_setCursorLcd
                           3424 ;	setting.c:32: displayStringLcd( "Set Date & Time" );
   0E71 90s00r85           3425 	mov	dptr,#__str_7
   0E74 75 F0 80           3426 	mov	b,#0x80
   0E77 12s01r6B           3427 	lcall	_displayStringLcd
                           3428 ;	setting.c:33: setCursorLcd(  1, 5 );
   0E7A 75*06 05           3429 	mov	_setCursorLcd_PARM_2,#0x05
   0E7D 75*07 00           3430 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   0E80 90 00 01           3431 	mov	dptr,#0x0001
   0E83 12s02r10           3432 	lcall	_setCursorLcd
                           3433 ;	setting.c:34: RTC_sendToDisplay( RTC_get( HOUR ) );
   0E86 75 82 02           3434 	mov	dpl,#0x02
   0E89 12s07rAF           3435 	lcall	_RTC_get
   0E8C 12s08rAB           3436 	lcall	_RTC_sendToDisplay
                           3437 ;	setting.c:35: displayCharLcd(':');
   0E8F 75 82 3A           3438 	mov	dpl,#0x3A
   0E92 12s01r63           3439 	lcall	_displayCharLcd
                           3440 ;	setting.c:36: RTC_sendToDisplay( RTC_get( MIN ) );
   0E95 75 82 01           3441 	mov	dpl,#0x01
   0E98 12s07rAF           3442 	lcall	_RTC_get
   0E9B 12s08rAB           3443 	lcall	_RTC_sendToDisplay
                           3444 ;	setting.c:37: displayCharLcd(':');
   0E9E 75 82 3A           3445 	mov	dpl,#0x3A
   0EA1 12s01r63           3446 	lcall	_displayCharLcd
                           3447 ;	setting.c:38: RTC_sendToDisplay( RTC_get( SEC ) );
   0EA4 75 82 00           3448 	mov	dpl,#0x00
   0EA7 12s07rAF           3449 	lcall	_RTC_get
   0EAA 12s08rAB           3450 	lcall	_RTC_sendToDisplay
                           3451 ;	setting.c:40: setCursorLcd( 2, 5 );
   0EAD 75*06 05           3452 	mov	_setCursorLcd_PARM_2,#0x05
   0EB0 75*07 00           3453 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   0EB3 90 00 02           3454 	mov	dptr,#0x0002
   0EB6 12s02r10           3455 	lcall	_setCursorLcd
                           3456 ;	setting.c:41: displayStringLcd("Enter Minute:");
   0EB9 90s00r95           3457 	mov	dptr,#__str_8
   0EBC 75 F0 80           3458 	mov	b,#0x80
   0EBF 12s01r6B           3459 	lcall	_displayStringLcd
                           3460 ;	setting.c:43: setCursorLcd( 0, 0);
   0EC2 E4                 3461 	clr	a
   0EC3 F5*06              3462 	mov	_setCursorLcd_PARM_2,a
   0EC5 F5*07              3463 	mov	(_setCursorLcd_PARM_2 + 1),a
   0EC7 F5 82              3464 	mov	dpl,a
   0EC9 F5 83              3465 	mov	dph,a
   0ECB 12s02r10           3466 	lcall	_setCursorLcd
                           3467 ;	setting.c:45: time[0] = handleScreenKeypadLoop( );
   0ECE 12s09rE9           3468 	lcall	_handleScreenKeypadLoop
   0ED1 AD 82              3469 	mov	r5,dpl
   0ED3 AE 83              3470 	mov	r6,dph
   0ED5 8D*1E              3471 	mov	(_SettingActivity_time_1_184 + 0),r5
   0ED7 8E*1F              3472 	mov	(_SettingActivity_time_1_184 + 1),r6
                           3473 ;	setting.c:46: if( time[0] == -1 )
   0ED9 BD FF 04           3474 	cjne	r5,#0xFF,00102$
   0EDC BE FF 01           3475 	cjne	r6,#0xFF,00102$
                           3476 ;	setting.c:48: return;
   0EDF 22                 3477 	ret
   0EE0                    3478 00102$:
                           3479 ;	setting.c:51: setCursorLcd( 2, 5 );
   0EE0 75*06 05           3480 	mov	_setCursorLcd_PARM_2,#0x05
   0EE3 75*07 00           3481 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   0EE6 90 00 02           3482 	mov	dptr,#0x0002
   0EE9 12s02r10           3483 	lcall	_setCursorLcd
                           3484 ;	setting.c:52: for( iLp = 0; iLp < (10 ) ; iLp ++)
   0EEC 7E 00              3485 	mov	r6,#0x00
   0EEE                    3486 00126$:
   0EEE C3                 3487 	clr	c
   0EEF EE                 3488 	mov	a,r6
   0EF0 64 80              3489 	xrl	a,#0x80
   0EF2 94 8A              3490 	subb	a,#0x8a
   0EF4 50 0D              3491 	jnc	00129$
                           3492 ;	setting.c:54: displayCharLcd( 0x20 );
   0EF6 75 82 20           3493 	mov	dpl,#0x20
   0EF9 C0 06              3494 	push	ar6
   0EFB 12s01r63           3495 	lcall	_displayCharLcd
   0EFE D0 06              3496 	pop	ar6
                           3497 ;	setting.c:52: for( iLp = 0; iLp < (10 ) ; iLp ++)
   0F00 0E                 3498 	inc	r6
   0F01 80 EB              3499 	sjmp	00126$
   0F03                    3500 00129$:
                           3501 ;	setting.c:56: setCursorLcd( 3, 5 );
   0F03 75*06 05           3502 	mov	_setCursorLcd_PARM_2,#0x05
   0F06 75*07 00           3503 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   0F09 90 00 03           3504 	mov	dptr,#0x0003
   0F0C 12s02r10           3505 	lcall	_setCursorLcd
                           3506 ;	setting.c:57: for( iLp = 0; iLp < (10 ) ; iLp ++)
   0F0F 7E 00              3507 	mov	r6,#0x00
   0F11                    3508 00130$:
   0F11 C3                 3509 	clr	c
   0F12 EE                 3510 	mov	a,r6
   0F13 64 80              3511 	xrl	a,#0x80
   0F15 94 8A              3512 	subb	a,#0x8a
   0F17 50 0D              3513 	jnc	00133$
                           3514 ;	setting.c:59: displayCharLcd( 0x20 );
   0F19 75 82 20           3515 	mov	dpl,#0x20
   0F1C C0 06              3516 	push	ar6
   0F1E 12s01r63           3517 	lcall	_displayCharLcd
   0F21 D0 06              3518 	pop	ar6
                           3519 ;	setting.c:57: for( iLp = 0; iLp < (10 ) ; iLp ++)
   0F23 0E                 3520 	inc	r6
   0F24 80 EB              3521 	sjmp	00130$
   0F26                    3522 00133$:
                           3523 ;	setting.c:62: setCursorLcd( 2, 5 );
   0F26 75*06 05           3524 	mov	_setCursorLcd_PARM_2,#0x05
   0F29 75*07 00           3525 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   0F2C 90 00 02           3526 	mov	dptr,#0x0002
   0F2F 12s02r10           3527 	lcall	_setCursorLcd
                           3528 ;	setting.c:63: displayStringLcd("Enter Hours:");
   0F32 90s00rA3           3529 	mov	dptr,#__str_9
   0F35 75 F0 80           3530 	mov	b,#0x80
   0F38 12s01r6B           3531 	lcall	_displayStringLcd
                           3532 ;	setting.c:65: setCursorLcd( 0, 0);	
   0F3B E4                 3533 	clr	a
   0F3C F5*06              3534 	mov	_setCursorLcd_PARM_2,a
   0F3E F5*07              3535 	mov	(_setCursorLcd_PARM_2 + 1),a
   0F40 F5 82              3536 	mov	dpl,a
   0F42 F5 83              3537 	mov	dph,a
   0F44 12s02r10           3538 	lcall	_setCursorLcd
                           3539 ;	setting.c:66: time[1] = handleScreenKeypadLoop( );
   0F47 12s09rE9           3540 	lcall	_handleScreenKeypadLoop
   0F4A AD 82              3541 	mov	r5,dpl
   0F4C AE 83              3542 	mov	r6,dph
   0F4E 8D*20              3543 	mov	((_SettingActivity_time_1_184 + 0x0002) + 0),r5
   0F50 8E*21              3544 	mov	((_SettingActivity_time_1_184 + 0x0002) + 1),r6
                           3545 ;	setting.c:68: if( time[1] == -1 )
   0F52 AB*20              3546 	mov	r3,(_SettingActivity_time_1_184 + 0x0002)
   0F54 AC*21              3547 	mov	r4,((_SettingActivity_time_1_184 + 0x0002) + 1)
   0F56 BD FF 04           3548 	cjne	r5,#0xFF,00109$
   0F59 BE FF 01           3549 	cjne	r6,#0xFF,00109$
                           3550 ;	setting.c:70: return;
   0F5C 22                 3551 	ret
   0F5D                    3552 00109$:
                           3553 ;	setting.c:73: else if( time[0] <=60 && time[1] <= 24  && time[0] != 0 && time[1] != 0)
   0F5D C3                 3554 	clr	c
   0F5E 74 3C              3555 	mov	a,#0x3C
   0F60 95*1E              3556 	subb	a,_SettingActivity_time_1_184
   0F62 E4                 3557 	clr	a
   0F63 64 80              3558 	xrl	a,#0x80
   0F65 85*1F F0           3559 	mov	b,(_SettingActivity_time_1_184 + 1)
   0F68 63 F0 80           3560 	xrl	b,#0x80
   0F6B 95 F0              3561 	subb	a,b
   0F6D 50 03              3562 	jnc	00337$
   0F6F 02s10rBC           3563 	ljmp	00110$
   0F72                    3564 00337$:
   0F72 C3                 3565 	clr	c
   0F73 74 18              3566 	mov	a,#0x18
   0F75 9B                 3567 	subb	a,r3
   0F76 E4                 3568 	clr	a
   0F77 64 80              3569 	xrl	a,#0x80
   0F79 8C F0              3570 	mov	b,r4
   0F7B 63 F0 80           3571 	xrl	b,#0x80
   0F7E 95 F0              3572 	subb	a,b
   0F80 50 03              3573 	jnc	00338$
   0F82 02s10rBC           3574 	ljmp	00110$
   0F85                    3575 00338$:
   0F85 E5*1E              3576 	mov	a,_SettingActivity_time_1_184
   0F87 45*1F              3577 	orl	a,(_SettingActivity_time_1_184 + 1)
   0F89 70 03              3578 	jnz	00339$
   0F8B 02s10rBC           3579 	ljmp	00110$
   0F8E                    3580 00339$:
   0F8E EB                 3581 	mov	a,r3
   0F8F 4C                 3582 	orl	a,r4
   0F90 70 03              3583 	jnz	00340$
   0F92 02s10rBC           3584 	ljmp	00110$
   0F95                    3585 00340$:
                           3586 ;	setting.c:76: for( ni = 0; ni < time[0] / 10 ; ni ++	)
   0F95 7E 00              3587 	mov	r6,#0x00
   0F97 7C 00              3588 	mov	r4,#0x00
   0F99 7D 00              3589 	mov	r5,#0x00
   0F9B                    3590 00134$:
   0F9B 85*1E 82           3591 	mov	dpl,_SettingActivity_time_1_184
   0F9E 85*1F 83           3592 	mov	dph,(_SettingActivity_time_1_184 + 1)
   0FA1 75*00 0A           3593 	mov	__divsint_PARM_2,#0x0A
   0FA4 75*01 00           3594 	mov	(__divsint_PARM_2 + 1),#0x00
   0FA7 C0 06              3595 	push	ar6
   0FA9 C0 05              3596 	push	ar5
   0FAB C0 04              3597 	push	ar4
   0FAD 12s00r00           3598 	lcall	__divsint
   0FB0 AA 82              3599 	mov	r2,dpl
   0FB2 AB 83              3600 	mov	r3,dph
   0FB4 D0 04              3601 	pop	ar4
   0FB6 D0 05              3602 	pop	ar5
   0FB8 D0 06              3603 	pop	ar6
   0FBA C3                 3604 	clr	c
   0FBB EC                 3605 	mov	a,r4
   0FBC 9A                 3606 	subb	a,r2
   0FBD ED                 3607 	mov	a,r5
   0FBE 64 80              3608 	xrl	a,#0x80
   0FC0 8B F0              3609 	mov	b,r3
   0FC2 63 F0 80           3610 	xrl	b,#0x80
   0FC5 95 F0              3611 	subb	a,b
   0FC7 50 0A              3612 	jnc	00260$
                           3613 ;	setting.c:77: cXVal++;
   0FC9 0E                 3614 	inc	r6
   0FCA 8E 07              3615 	mov	ar7,r6
                           3616 ;	setting.c:76: for( ni = 0; ni < time[0] / 10 ; ni ++	)
   0FCC 0C                 3617 	inc	r4
   0FCD BC 00 CB           3618 	cjne	r4,#0x00,00134$
   0FD0 0D                 3619 	inc	r5
   0FD1 80 C8              3620 	sjmp	00134$
   0FD3                    3621 00260$:
   0FD3 8E 07              3622 	mov	ar7,r6
                           3623 ;	setting.c:78: for( ni = 0; ni < time[0] % 10 ; ni ++	)
   0FD5 7E 00              3624 	mov	r6,#0x00
   0FD7 7C 00              3625 	mov	r4,#0x00
   0FD9 7D 00              3626 	mov	r5,#0x00
   0FDB                    3627 00138$:
   0FDB 85*1E 82           3628 	mov	dpl,_SettingActivity_time_1_184
   0FDE 85*1F 83           3629 	mov	dph,(_SettingActivity_time_1_184 + 1)
   0FE1 75*00 0A           3630 	mov	__modsint_PARM_2,#0x0A
   0FE4 75*01 00           3631 	mov	(__modsint_PARM_2 + 1),#0x00
   0FE7 C0 07              3632 	push	ar7
   0FE9 C0 06              3633 	push	ar6
   0FEB C0 05              3634 	push	ar5
   0FED C0 04              3635 	push	ar4
   0FEF 12s00r00           3636 	lcall	__modsint
   0FF2 AA 82              3637 	mov	r2,dpl
   0FF4 AB 83              3638 	mov	r3,dph
   0FF6 D0 04              3639 	pop	ar4
   0FF8 D0 05              3640 	pop	ar5
   0FFA D0 06              3641 	pop	ar6
   0FFC D0 07              3642 	pop	ar7
   0FFE C3                 3643 	clr	c
   0FFF EC                 3644 	mov	a,r4
   1000 9A                 3645 	subb	a,r2
   1001 ED                 3646 	mov	a,r5
   1002 64 80              3647 	xrl	a,#0x80
   1004 8B F0              3648 	mov	b,r3
   1006 63 F0 80           3649 	xrl	b,#0x80
   1009 95 F0              3650 	subb	a,b
   100B 50 08              3651 	jnc	00141$
                           3652 ;	setting.c:79: cYVal++;
   100D 0E                 3653 	inc	r6
                           3654 ;	setting.c:78: for( ni = 0; ni < time[0] % 10 ; ni ++	)
   100E 0C                 3655 	inc	r4
   100F BC 00 C9           3656 	cjne	r4,#0x00,00138$
   1012 0D                 3657 	inc	r5
   1013 80 C6              3658 	sjmp	00138$
   1015                    3659 00141$:
                           3660 ;	setting.c:81: cXVal <<=4;
   1015 EF                 3661 	mov	a,r7
   1016 C4                 3662 	swap	a
   1017 54 F0              3663 	anl	a,#0xF0
   1019 FF                 3664 	mov	r7,a
                           3665 ;	setting.c:82: cXVal &= 0xf0;
   101A 53 07 F0           3666 	anl	ar7,#0xF0
                           3667 ;	setting.c:83: cYVal &=0x0f;
   101D 53 06 0F           3668 	anl	ar6,#0x0F
                           3669 ;	setting.c:84: cXVal |= cYVal;
   1020 EE                 3670 	mov	a,r6
   1021 42 07              3671 	orl	ar7,a
                           3672 ;	setting.c:86: cYVal = 0x00;
                           3673 ;	setting.c:90: for( ni = 0; ni < time[1] / 10 ; ni ++	)
   1023 E4                 3674 	clr	a
   1024 FE                 3675 	mov	r6,a
   1025 FD                 3676 	mov	r5,a
   1026 F5*28              3677 	mov	_SettingActivity_ni_1_184,a
   1028 F5*29              3678 	mov	(_SettingActivity_ni_1_184 + 1),a
   102A                    3679 00142$:
   102A 85*20 82           3680 	mov	dpl,(_SettingActivity_time_1_184 + 0x0002)
   102D 85*21 83           3681 	mov	dph,((_SettingActivity_time_1_184 + 0x0002) + 1)
   1030 75*00 0A           3682 	mov	__divsint_PARM_2,#0x0A
   1033 75*01 00           3683 	mov	(__divsint_PARM_2 + 1),#0x00
   1036 C0 07              3684 	push	ar7
   1038 C0 05              3685 	push	ar5
   103A 12s00r00           3686 	lcall	__divsint
   103D AA 82              3687 	mov	r2,dpl
   103F AC 83              3688 	mov	r4,dph
   1041 D0 05              3689 	pop	ar5
   1043 D0 07              3690 	pop	ar7
   1045 C3                 3691 	clr	c
   1046 E5*28              3692 	mov	a,_SettingActivity_ni_1_184
   1048 9A                 3693 	subb	a,r2
   1049 E5*29              3694 	mov	a,(_SettingActivity_ni_1_184 + 1)
   104B 64 80              3695 	xrl	a,#0x80
   104D 8C F0              3696 	mov	b,r4
   104F 63 F0 80           3697 	xrl	b,#0x80
   1052 95 F0              3698 	subb	a,b
   1054 50 0D              3699 	jnc	00262$
                           3700 ;	setting.c:91: cYVal++;
   1056 0D                 3701 	inc	r5
   1057 8D 06              3702 	mov	ar6,r5
                           3703 ;	setting.c:90: for( ni = 0; ni < time[1] / 10 ; ni ++	)
   1059 05*28              3704 	inc	_SettingActivity_ni_1_184
   105B E4                 3705 	clr	a
   105C B5*28 CB           3706 	cjne	a,_SettingActivity_ni_1_184,00142$
   105F 05*29              3707 	inc	(_SettingActivity_ni_1_184 + 1)
   1061 80 C7              3708 	sjmp	00142$
   1063                    3709 00262$:
   1063 8D 06              3710 	mov	ar6,r5
                           3711 ;	setting.c:92: for( ni = 0; ni < time[1] % 10 ; ni ++	)
   1065 75*1C 00           3712 	mov	_SettingActivity_cZVal_1_184,#0x00
   1068 7B 00              3713 	mov	r3,#0x00
   106A 7C 00              3714 	mov	r4,#0x00
   106C                    3715 00146$:
   106C 85*20 82           3716 	mov	dpl,(_SettingActivity_time_1_184 + 0x0002)
   106F 85*21 83           3717 	mov	dph,((_SettingActivity_time_1_184 + 0x0002) + 1)
   1072 75*00 0A           3718 	mov	__modsint_PARM_2,#0x0A
   1075 75*01 00           3719 	mov	(__modsint_PARM_2 + 1),#0x00
   1078 C0 07              3720 	push	ar7
   107A C0 06              3721 	push	ar6
   107C C0 04              3722 	push	ar4
   107E C0 03              3723 	push	ar3
   1080 12s00r00           3724 	lcall	__modsint
   1083 AA 82              3725 	mov	r2,dpl
   1085 AD 83              3726 	mov	r5,dph
   1087 D0 03              3727 	pop	ar3
   1089 D0 04              3728 	pop	ar4
   108B D0 06              3729 	pop	ar6
   108D D0 07              3730 	pop	ar7
   108F C3                 3731 	clr	c
   1090 EB                 3732 	mov	a,r3
   1091 9A                 3733 	subb	a,r2
   1092 EC                 3734 	mov	a,r4
   1093 64 80              3735 	xrl	a,#0x80
   1095 8D F0              3736 	mov	b,r5
   1097 63 F0 80           3737 	xrl	b,#0x80
   109A 95 F0              3738 	subb	a,b
   109C 50 09              3739 	jnc	00149$
                           3740 ;	setting.c:93: cZVal++;
   109E 05*1C              3741 	inc	_SettingActivity_cZVal_1_184
                           3742 ;	setting.c:92: for( ni = 0; ni < time[1] % 10 ; ni ++	)
   10A0 0B                 3743 	inc	r3
   10A1 BB 00 C8           3744 	cjne	r3,#0x00,00146$
   10A4 0C                 3745 	inc	r4
   10A5 80 C5              3746 	sjmp	00146$
   10A7                    3747 00149$:
                           3748 ;	setting.c:95: cYVal <<=4;
   10A7 EE                 3749 	mov	a,r6
   10A8 C4                 3750 	swap	a
   10A9 54 F0              3751 	anl	a,#0xF0
   10AB FE                 3752 	mov	r6,a
                           3753 ;	setting.c:96: cYVal &= 0xf0;
   10AC 53 06 F0           3754 	anl	ar6,#0xF0
                           3755 ;	setting.c:97: cZVal &=0x0f;
   10AF 74 0F              3756 	mov	a,#0x0F
   10B1 55*1C              3757 	anl	a,_SettingActivity_cZVal_1_184
                           3758 ;	setting.c:98: cYVal |= cZVal;
   10B3 42 06              3759 	orl	ar6,a
                           3760 ;	setting.c:100: RTC_settime( cYVal, cXVal );
   10B5 8F*13              3761 	mov	_RTC_settime_PARM_2,r7
   10B7 8E 82              3762 	mov	dpl,r6
   10B9 12s07rE1           3763 	lcall	_RTC_settime
   10BC                    3764 00110$:
                           3765 ;	setting.c:102: cXVal = 0x00;
                           3766 ;	setting.c:107: setCursorLcd( 1, 5 );
   10BC 75*06 05           3767 	mov	_setCursorLcd_PARM_2,#0x05
   10BF 75*07 00           3768 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   10C2 90 00 01           3769 	mov	dptr,#0x0001
   10C5 12s02r10           3770 	lcall	_setCursorLcd
                           3771 ;	setting.c:108: for( iLp = 0; iLp < (10) ; iLp ++)
   10C8 7C 00              3772 	mov	r4,#0x00
   10CA                    3773 00150$:
   10CA C3                 3774 	clr	c
   10CB EC                 3775 	mov	a,r4
   10CC 64 80              3776 	xrl	a,#0x80
   10CE 94 8A              3777 	subb	a,#0x8a
   10D0 50 0D              3778 	jnc	00153$
                           3779 ;	setting.c:110: displayCharLcd( 0x20 );
   10D2 75 82 20           3780 	mov	dpl,#0x20
   10D5 C0 04              3781 	push	ar4
   10D7 12s01r63           3782 	lcall	_displayCharLcd
   10DA D0 04              3783 	pop	ar4
                           3784 ;	setting.c:108: for( iLp = 0; iLp < (10) ; iLp ++)
   10DC 0C                 3785 	inc	r4
   10DD 80 EB              3786 	sjmp	00150$
   10DF                    3787 00153$:
                           3788 ;	setting.c:112: setCursorLcd( 1, 5 );
   10DF 75*06 05           3789 	mov	_setCursorLcd_PARM_2,#0x05
   10E2 75*07 00           3790 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   10E5 90 00 01           3791 	mov	dptr,#0x0001
   10E8 12s02r10           3792 	lcall	_setCursorLcd
                           3793 ;	setting.c:114: showRtcDateDay();					
   10EB 12s07r0A           3794 	lcall	_showRtcDateDay
                           3795 ;	setting.c:116: setCursorLcd( 2, 5 );
   10EE 75*06 05           3796 	mov	_setCursorLcd_PARM_2,#0x05
   10F1 75*07 00           3797 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   10F4 90 00 02           3798 	mov	dptr,#0x0002
   10F7 12s02r10           3799 	lcall	_setCursorLcd
                           3800 ;	setting.c:117: for( iLp = 0; iLp < ( 10 ) ; iLp ++)
   10FA 7C 00              3801 	mov	r4,#0x00
   10FC                    3802 00154$:
   10FC C3                 3803 	clr	c
   10FD EC                 3804 	mov	a,r4
   10FE 64 80              3805 	xrl	a,#0x80
   1100 94 8A              3806 	subb	a,#0x8a
   1102 50 0D              3807 	jnc	00157$
                           3808 ;	setting.c:119: displayCharLcd( 0x20 );
   1104 75 82 20           3809 	mov	dpl,#0x20
   1107 C0 04              3810 	push	ar4
   1109 12s01r63           3811 	lcall	_displayCharLcd
   110C D0 04              3812 	pop	ar4
                           3813 ;	setting.c:117: for( iLp = 0; iLp < ( 10 ) ; iLp ++)
   110E 0C                 3814 	inc	r4
   110F 80 EB              3815 	sjmp	00154$
   1111                    3816 00157$:
                           3817 ;	setting.c:121: setCursorLcd( 3, 5 );
   1111 75*06 05           3818 	mov	_setCursorLcd_PARM_2,#0x05
   1114 75*07 00           3819 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   1117 90 00 03           3820 	mov	dptr,#0x0003
   111A 12s02r10           3821 	lcall	_setCursorLcd
                           3822 ;	setting.c:122: for( iLp = 0; iLp < ( 10 ) ; iLp ++)
   111D 7C 00              3823 	mov	r4,#0x00
   111F                    3824 00158$:
   111F C3                 3825 	clr	c
   1120 EC                 3826 	mov	a,r4
   1121 64 80              3827 	xrl	a,#0x80
   1123 94 8A              3828 	subb	a,#0x8a
   1125 50 0D              3829 	jnc	00161$
                           3830 ;	setting.c:124: displayCharLcd( 0x20 );
   1127 75 82 20           3831 	mov	dpl,#0x20
   112A C0 04              3832 	push	ar4
   112C 12s01r63           3833 	lcall	_displayCharLcd
   112F D0 04              3834 	pop	ar4
                           3835 ;	setting.c:122: for( iLp = 0; iLp < ( 10 ) ; iLp ++)
   1131 0C                 3836 	inc	r4
   1132 80 EB              3837 	sjmp	00158$
   1134                    3838 00161$:
                           3839 ;	setting.c:127: setCursorLcd( 2, 5 );
   1134 75*06 05           3840 	mov	_setCursorLcd_PARM_2,#0x05
   1137 75*07 00           3841 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   113A 90 00 02           3842 	mov	dptr,#0x0002
   113D 12s02r10           3843 	lcall	_setCursorLcd
                           3844 ;	setting.c:128: displayStringLcd("Enter Date");
   1140 90s00rB0           3845 	mov	dptr,#__str_10
   1143 75 F0 80           3846 	mov	b,#0x80
   1146 12s01r6B           3847 	lcall	_displayStringLcd
                           3848 ;	setting.c:130: setCursorLcd( 0, 0);	
   1149 E4                 3849 	clr	a
   114A F5*06              3850 	mov	_setCursorLcd_PARM_2,a
   114C F5*07              3851 	mov	(_setCursorLcd_PARM_2 + 1),a
   114E F5 82              3852 	mov	dpl,a
   1150 F5 83              3853 	mov	dph,a
   1152 12s02r10           3854 	lcall	_setCursorLcd
                           3855 ;	setting.c:131: date[0] = handleScreenKeypadLoop( );
   1155 12s09rE9           3856 	lcall	_handleScreenKeypadLoop
   1158 E5 82              3857 	mov	a,dpl
   115A 85 83 F0           3858 	mov	b,dph
   115D F5*22              3859 	mov	(_SettingActivity_date_1_184 + 0),a
   115F 85 F0*23           3860 	mov	(_SettingActivity_date_1_184 + 1),b
                           3861 ;	setting.c:133: setCursorLcd( 2, 5 );
   1162 75*06 05           3862 	mov	_setCursorLcd_PARM_2,#0x05
   1165 75*07 00           3863 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   1168 90 00 02           3864 	mov	dptr,#0x0002
   116B 12s02r10           3865 	lcall	_setCursorLcd
                           3866 ;	setting.c:134: for( iLp = 0; iLp < (10 - 5) ; iLp ++)
   116E 7C 00              3867 	mov	r4,#0x00
   1170                    3868 00162$:
   1170 C3                 3869 	clr	c
   1171 EC                 3870 	mov	a,r4
   1172 64 80              3871 	xrl	a,#0x80
   1174 94 85              3872 	subb	a,#0x85
   1176 50 0D              3873 	jnc	00165$
                           3874 ;	setting.c:136: displayCharLcd( 0x20 );
   1178 75 82 20           3875 	mov	dpl,#0x20
   117B C0 04              3876 	push	ar4
   117D 12s01r63           3877 	lcall	_displayCharLcd
   1180 D0 04              3878 	pop	ar4
                           3879 ;	setting.c:134: for( iLp = 0; iLp < (10 - 5) ; iLp ++)
   1182 0C                 3880 	inc	r4
   1183 80 EB              3881 	sjmp	00162$
   1185                    3882 00165$:
                           3883 ;	setting.c:138: setCursorLcd( 3, 5 );
   1185 75*06 05           3884 	mov	_setCursorLcd_PARM_2,#0x05
   1188 75*07 00           3885 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   118B 90 00 03           3886 	mov	dptr,#0x0003
   118E 12s02r10           3887 	lcall	_setCursorLcd
                           3888 ;	setting.c:139: for( iLp = 0; iLp < (10 - 5) ; iLp ++)
   1191 7C 00              3889 	mov	r4,#0x00
   1193                    3890 00166$:
   1193 C3                 3891 	clr	c
   1194 EC                 3892 	mov	a,r4
   1195 64 80              3893 	xrl	a,#0x80
   1197 94 85              3894 	subb	a,#0x85
   1199 50 0D              3895 	jnc	00169$
                           3896 ;	setting.c:141: displayCharLcd( 0x20 );
   119B 75 82 20           3897 	mov	dpl,#0x20
   119E C0 04              3898 	push	ar4
   11A0 12s01r63           3899 	lcall	_displayCharLcd
   11A3 D0 04              3900 	pop	ar4
                           3901 ;	setting.c:139: for( iLp = 0; iLp < (10 - 5) ; iLp ++)
   11A5 0C                 3902 	inc	r4
   11A6 80 EB              3903 	sjmp	00166$
   11A8                    3904 00169$:
                           3905 ;	setting.c:144: setCursorLcd( 2, 5 );
   11A8 75*06 05           3906 	mov	_setCursorLcd_PARM_2,#0x05
   11AB 75*07 00           3907 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   11AE 90 00 02           3908 	mov	dptr,#0x0002
   11B1 12s02r10           3909 	lcall	_setCursorLcd
                           3910 ;	setting.c:145: displayStringLcd("Enter Month");
   11B4 90s00rBB           3911 	mov	dptr,#__str_11
   11B7 75 F0 80           3912 	mov	b,#0x80
   11BA 12s01r6B           3913 	lcall	_displayStringLcd
                           3914 ;	setting.c:147: setCursorLcd( 0, 0);	
   11BD E4                 3915 	clr	a
   11BE F5*06              3916 	mov	_setCursorLcd_PARM_2,a
   11C0 F5*07              3917 	mov	(_setCursorLcd_PARM_2 + 1),a
   11C2 F5 82              3918 	mov	dpl,a
   11C4 F5 83              3919 	mov	dph,a
   11C6 12s02r10           3920 	lcall	_setCursorLcd
                           3921 ;	setting.c:148: date[1] = handleScreenKeypadLoop( );
   11C9 12s09rE9           3922 	lcall	_handleScreenKeypadLoop
   11CC E5 82              3923 	mov	a,dpl
   11CE 85 83 F0           3924 	mov	b,dph
   11D1 F5*24              3925 	mov	((_SettingActivity_date_1_184 + 0x0002) + 0),a
   11D3 85 F0*25           3926 	mov	((_SettingActivity_date_1_184 + 0x0002) + 1),b
                           3927 ;	setting.c:150: setCursorLcd( 2, 5 );
   11D6 75*06 05           3928 	mov	_setCursorLcd_PARM_2,#0x05
   11D9 75*07 00           3929 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   11DC 90 00 02           3930 	mov	dptr,#0x0002
   11DF 12s02r10           3931 	lcall	_setCursorLcd
                           3932 ;	setting.c:151: for( iLp = 0; iLp < (10 - 5) ; iLp ++)
   11E2 7C 00              3933 	mov	r4,#0x00
   11E4                    3934 00170$:
   11E4 C3                 3935 	clr	c
   11E5 EC                 3936 	mov	a,r4
   11E6 64 80              3937 	xrl	a,#0x80
   11E8 94 85              3938 	subb	a,#0x85
   11EA 50 0D              3939 	jnc	00173$
                           3940 ;	setting.c:153: displayCharLcd( 0x20 );
   11EC 75 82 20           3941 	mov	dpl,#0x20
   11EF C0 04              3942 	push	ar4
   11F1 12s01r63           3943 	lcall	_displayCharLcd
   11F4 D0 04              3944 	pop	ar4
                           3945 ;	setting.c:151: for( iLp = 0; iLp < (10 - 5) ; iLp ++)
   11F6 0C                 3946 	inc	r4
   11F7 80 EB              3947 	sjmp	00170$
   11F9                    3948 00173$:
                           3949 ;	setting.c:155: setCursorLcd( 3, 5 );
   11F9 75*06 05           3950 	mov	_setCursorLcd_PARM_2,#0x05
   11FC 75*07 00           3951 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   11FF 90 00 03           3952 	mov	dptr,#0x0003
   1202 12s02r10           3953 	lcall	_setCursorLcd
                           3954 ;	setting.c:156: for( iLp = 0; iLp < (10 - 5) ; iLp ++)
   1205 7C 00              3955 	mov	r4,#0x00
   1207                    3956 00174$:
   1207 C3                 3957 	clr	c
   1208 EC                 3958 	mov	a,r4
   1209 64 80              3959 	xrl	a,#0x80
   120B 94 85              3960 	subb	a,#0x85
   120D 50 0D              3961 	jnc	00177$
                           3962 ;	setting.c:158: displayCharLcd( 0x20 );
   120F 75 82 20           3963 	mov	dpl,#0x20
   1212 C0 04              3964 	push	ar4
   1214 12s01r63           3965 	lcall	_displayCharLcd
   1217 D0 04              3966 	pop	ar4
                           3967 ;	setting.c:156: for( iLp = 0; iLp < (10 - 5) ; iLp ++)
   1219 0C                 3968 	inc	r4
   121A 80 EB              3969 	sjmp	00174$
   121C                    3970 00177$:
                           3971 ;	setting.c:161: setCursorLcd( 2, 5 );
   121C 75*06 05           3972 	mov	_setCursorLcd_PARM_2,#0x05
   121F 75*07 00           3973 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   1222 90 00 02           3974 	mov	dptr,#0x0002
   1225 12s02r10           3975 	lcall	_setCursorLcd
                           3976 ;	setting.c:162: displayStringLcd("Enter Year:20xx");
   1228 90s00rC7           3977 	mov	dptr,#__str_12
   122B 75 F0 80           3978 	mov	b,#0x80
   122E 12s01r6B           3979 	lcall	_displayStringLcd
                           3980 ;	setting.c:164: setCursorLcd( 0, 0);	
   1231 E4                 3981 	clr	a
   1232 F5*06              3982 	mov	_setCursorLcd_PARM_2,a
   1234 F5*07              3983 	mov	(_setCursorLcd_PARM_2 + 1),a
   1236 F5 82              3984 	mov	dpl,a
   1238 F5 83              3985 	mov	dph,a
   123A 12s02r10           3986 	lcall	_setCursorLcd
                           3987 ;	setting.c:165: date[2] = handleScreenKeypadLoop( );
   123D 12s09rE9           3988 	lcall	_handleScreenKeypadLoop
   1240 E5 82              3989 	mov	a,dpl
   1242 85 83 F0           3990 	mov	b,dph
   1245 F5*26              3991 	mov	((_SettingActivity_date_1_184 + 0x0004) + 0),a
   1247 85 F0*27           3992 	mov	((_SettingActivity_date_1_184 + 0x0004) + 1),b
                           3993 ;	setting.c:167: if( date[0] == -1 || date[1] == -1 || date[2] == -1 )
   124A 74 FF              3994 	mov	a,#0xFF
   124C B5*22 06           3995 	cjne	a,_SettingActivity_date_1_184,00356$
   124F 74 FF              3996 	mov	a,#0xFF
   1251 B5*23 01           3997 	cjne	a,(_SettingActivity_date_1_184 + 1),00356$
   1254 22                 3998 	ret
   1255                    3999 00356$:
   1255 74 FF              4000 	mov	a,#0xFF
   1257 B5*24 06           4001 	cjne	a,(_SettingActivity_date_1_184 + 0x0002),00357$
   125A 74 FF              4002 	mov	a,#0xFF
   125C B5*25 01           4003 	cjne	a,((_SettingActivity_date_1_184 + 0x0002) + 1),00357$
   125F 22                 4004 	ret
   1260                    4005 00357$:
   1260 AB*26              4006 	mov	r3,(_SettingActivity_date_1_184 + 0x0004)
   1262 AC*27              4007 	mov	r4,((_SettingActivity_date_1_184 + 0x0004) + 1)
   1264 BB FF 04           4008 	cjne	r3,#0xFF,00118$
   1267 BC FF 01           4009 	cjne	r4,#0xFF,00118$
                           4010 ;	setting.c:169: return;
   126A 22                 4011 	ret
   126B                    4012 00118$:
                           4013 ;	setting.c:171: else if( date[0] <= 31 && date[1] <= 12  && date[0] != 0 && date[1] != 0 && date[2] != 0)				//convertion of INT to char...... 20 -> 0x20
   126B C3                 4014 	clr	c
   126C 74 1F              4015 	mov	a,#0x1F
   126E 95*22              4016 	subb	a,_SettingActivity_date_1_184
   1270 E4                 4017 	clr	a
   1271 64 80              4018 	xrl	a,#0x80
   1273 85*23 F0           4019 	mov	b,(_SettingActivity_date_1_184 + 1)
   1276 63 F0 80           4020 	xrl	b,#0x80
   1279 95 F0              4021 	subb	a,b
   127B 50 01              4022 	jnc	00360$
   127D 22                 4023 	ret
   127E                    4024 00360$:
   127E C3                 4025 	clr	c
   127F 74 0C              4026 	mov	a,#0x0C
   1281 95*24              4027 	subb	a,(_SettingActivity_date_1_184 + 0x0002)
   1283 E4                 4028 	clr	a
   1284 64 80              4029 	xrl	a,#0x80
   1286 85*25 F0           4030 	mov	b,((_SettingActivity_date_1_184 + 0x0002) + 1)
   1289 63 F0 80           4031 	xrl	b,#0x80
   128C 95 F0              4032 	subb	a,b
   128E 50 01              4033 	jnc	00361$
   1290 22                 4034 	ret
   1291                    4035 00361$:
   1291 E5*22              4036 	mov	a,_SettingActivity_date_1_184
   1293 45*23              4037 	orl	a,(_SettingActivity_date_1_184 + 1)
   1295 70 01              4038 	jnz	00362$
   1297 22                 4039 	ret
   1298                    4040 00362$:
   1298 E5*24              4041 	mov	a,(_SettingActivity_date_1_184 + 0x0002)
   129A 45*25              4042 	orl	a,((_SettingActivity_date_1_184 + 0x0002) + 1)
   129C 70 01              4043 	jnz	00363$
   129E 22                 4044 	ret
   129F                    4045 00363$:
   129F EB                 4046 	mov	a,r3
   12A0 4C                 4047 	orl	a,r4
   12A1 70 01              4048 	jnz	00364$
   12A3 22                 4049 	ret
   12A4                    4050 00364$:
                           4051 ;	setting.c:173: for( ni = 0; ni < date[0] / 10 ; ni++	)			//date
   12A4 E4                 4052 	clr	a
   12A5 FC                 4053 	mov	r4,a
   12A6 F5*28              4054 	mov	_SettingActivity_ni_1_184,a
   12A8 F5*29              4055 	mov	(_SettingActivity_ni_1_184 + 1),a
   12AA                    4056 00178$:
   12AA 85*22 82           4057 	mov	dpl,_SettingActivity_date_1_184
   12AD 85*23 83           4058 	mov	dph,(_SettingActivity_date_1_184 + 1)
   12B0 75*00 0A           4059 	mov	__divsint_PARM_2,#0x0A
   12B3 75*01 00           4060 	mov	(__divsint_PARM_2 + 1),#0x00
   12B6 C0 04              4061 	push	ar4
   12B8 12s00r00           4062 	lcall	__divsint
   12BB AA 82              4063 	mov	r2,dpl
   12BD AB 83              4064 	mov	r3,dph
   12BF D0 04              4065 	pop	ar4
   12C1 C3                 4066 	clr	c
   12C2 E5*28              4067 	mov	a,_SettingActivity_ni_1_184
   12C4 9A                 4068 	subb	a,r2
   12C5 E5*29              4069 	mov	a,(_SettingActivity_ni_1_184 + 1)
   12C7 64 80              4070 	xrl	a,#0x80
   12C9 8B F0              4071 	mov	b,r3
   12CB 63 F0 80           4072 	xrl	b,#0x80
   12CE 95 F0              4073 	subb	a,b
   12D0 50 0D              4074 	jnc	00271$
                           4075 ;	setting.c:174: cXVal++;
   12D2 0C                 4076 	inc	r4
   12D3 8C 07              4077 	mov	ar7,r4
                           4078 ;	setting.c:173: for( ni = 0; ni < date[0] / 10 ; ni++	)			//date
   12D5 05*28              4079 	inc	_SettingActivity_ni_1_184
   12D7 E4                 4080 	clr	a
   12D8 B5*28 CF           4081 	cjne	a,_SettingActivity_ni_1_184,00178$
   12DB 05*29              4082 	inc	(_SettingActivity_ni_1_184 + 1)
   12DD 80 CB              4083 	sjmp	00178$
   12DF                    4084 00271$:
   12DF 8C 07              4085 	mov	ar7,r4
                           4086 ;	setting.c:175: for( ni = 0; ni < date[0] % 10 ; ni++	)
   12E1 E4                 4087 	clr	a
   12E2 FC                 4088 	mov	r4,a
   12E3 F5*28              4089 	mov	_SettingActivity_ni_1_184,a
   12E5 F5*29              4090 	mov	(_SettingActivity_ni_1_184 + 1),a
   12E7                    4091 00182$:
   12E7 85*22 82           4092 	mov	dpl,_SettingActivity_date_1_184
   12EA 85*23 83           4093 	mov	dph,(_SettingActivity_date_1_184 + 1)
   12ED 75*00 0A           4094 	mov	__modsint_PARM_2,#0x0A
   12F0 75*01 00           4095 	mov	(__modsint_PARM_2 + 1),#0x00
   12F3 C0 07              4096 	push	ar7
   12F5 C0 04              4097 	push	ar4
   12F7 12s00r00           4098 	lcall	__modsint
   12FA AA 82              4099 	mov	r2,dpl
   12FC AB 83              4100 	mov	r3,dph
   12FE D0 04              4101 	pop	ar4
   1300 D0 07              4102 	pop	ar7
   1302 C3                 4103 	clr	c
   1303 E5*28              4104 	mov	a,_SettingActivity_ni_1_184
   1305 9A                 4105 	subb	a,r2
   1306 E5*29              4106 	mov	a,(_SettingActivity_ni_1_184 + 1)
   1308 64 80              4107 	xrl	a,#0x80
   130A 8B F0              4108 	mov	b,r3
   130C 63 F0 80           4109 	xrl	b,#0x80
   130F 95 F0              4110 	subb	a,b
   1311 50 0B              4111 	jnc	00185$
                           4112 ;	setting.c:176: cYVal++;
   1313 0C                 4113 	inc	r4
                           4114 ;	setting.c:175: for( ni = 0; ni < date[0] % 10 ; ni++	)
   1314 05*28              4115 	inc	_SettingActivity_ni_1_184
   1316 E4                 4116 	clr	a
   1317 B5*28 CD           4117 	cjne	a,_SettingActivity_ni_1_184,00182$
   131A 05*29              4118 	inc	(_SettingActivity_ni_1_184 + 1)
   131C 80 C9              4119 	sjmp	00182$
   131E                    4120 00185$:
                           4121 ;	setting.c:178: cXVal <<=4;
   131E EF                 4122 	mov	a,r7
   131F C4                 4123 	swap	a
   1320 54 F0              4124 	anl	a,#0xF0
   1322 FF                 4125 	mov	r7,a
                           4126 ;	setting.c:179: cXVal &= 0xf0;
   1323 53 07 F0           4127 	anl	ar7,#0xF0
                           4128 ;	setting.c:180: cYVal &=0x0f;
   1326 74 0F              4129 	mov	a,#0x0F
   1328 5C                 4130 	anl	a,r4
                           4131 ;	setting.c:181: cXVal |= cYVal;			//date stored in XVal;
   1329 42 07              4132 	orl	ar7,a
                           4133 ;	setting.c:183: cYVal = 0x00;
                           4134 ;	setting.c:186: for( ni = 0; ni < date[1] / 10 ; ni++	)			//month
   132B E4                 4135 	clr	a
   132C FE                 4136 	mov	r6,a
   132D FC                 4137 	mov	r4,a
   132E F5*28              4138 	mov	_SettingActivity_ni_1_184,a
   1330 F5*29              4139 	mov	(_SettingActivity_ni_1_184 + 1),a
   1332                    4140 00186$:
   1332 85*24 82           4141 	mov	dpl,(_SettingActivity_date_1_184 + 0x0002)
   1335 85*25 83           4142 	mov	dph,((_SettingActivity_date_1_184 + 0x0002) + 1)
   1338 75*00 0A           4143 	mov	__divsint_PARM_2,#0x0A
   133B 75*01 00           4144 	mov	(__divsint_PARM_2 + 1),#0x00
   133E C0 07              4145 	push	ar7
   1340 C0 04              4146 	push	ar4
   1342 12s00r00           4147 	lcall	__divsint
   1345 AA 82              4148 	mov	r2,dpl
   1347 AB 83              4149 	mov	r3,dph
   1349 D0 04              4150 	pop	ar4
   134B D0 07              4151 	pop	ar7
   134D C3                 4152 	clr	c
   134E E5*28              4153 	mov	a,_SettingActivity_ni_1_184
   1350 9A                 4154 	subb	a,r2
   1351 E5*29              4155 	mov	a,(_SettingActivity_ni_1_184 + 1)
   1353 64 80              4156 	xrl	a,#0x80
   1355 8B F0              4157 	mov	b,r3
   1357 63 F0 80           4158 	xrl	b,#0x80
   135A 95 F0              4159 	subb	a,b
   135C 50 0D              4160 	jnc	00273$
                           4161 ;	setting.c:187: cYVal++;
   135E 0C                 4162 	inc	r4
   135F 8C 06              4163 	mov	ar6,r4
                           4164 ;	setting.c:186: for( ni = 0; ni < date[1] / 10 ; ni++	)			//month
   1361 05*28              4165 	inc	_SettingActivity_ni_1_184
   1363 E4                 4166 	clr	a
   1364 B5*28 CB           4167 	cjne	a,_SettingActivity_ni_1_184,00186$
   1367 05*29              4168 	inc	(_SettingActivity_ni_1_184 + 1)
   1369 80 C7              4169 	sjmp	00186$
   136B                    4170 00273$:
   136B 8C 06              4171 	mov	ar6,r4
                           4172 ;	setting.c:188: for( ni = 0; ni < date[1] % 10 ; ni++	)
   136D E4                 4173 	clr	a
   136E F5*1C              4174 	mov	_SettingActivity_cZVal_1_184,a
   1370 F5*28              4175 	mov	_SettingActivity_ni_1_184,a
   1372 F5*29              4176 	mov	(_SettingActivity_ni_1_184 + 1),a
   1374                    4177 00190$:
   1374 85*24 82           4178 	mov	dpl,(_SettingActivity_date_1_184 + 0x0002)
   1377 85*25 83           4179 	mov	dph,((_SettingActivity_date_1_184 + 0x0002) + 1)
   137A 75*00 0A           4180 	mov	__modsint_PARM_2,#0x0A
   137D 75*01 00           4181 	mov	(__modsint_PARM_2 + 1),#0x00
   1380 C0 07              4182 	push	ar7
   1382 C0 06              4183 	push	ar6
   1384 12s00r00           4184 	lcall	__modsint
   1387 AB 82              4185 	mov	r3,dpl
   1389 AC 83              4186 	mov	r4,dph
   138B D0 06              4187 	pop	ar6
   138D D0 07              4188 	pop	ar7
   138F C3                 4189 	clr	c
   1390 E5*28              4190 	mov	a,_SettingActivity_ni_1_184
   1392 9B                 4191 	subb	a,r3
   1393 E5*29              4192 	mov	a,(_SettingActivity_ni_1_184 + 1)
   1395 64 80              4193 	xrl	a,#0x80
   1397 8C F0              4194 	mov	b,r4
   1399 63 F0 80           4195 	xrl	b,#0x80
   139C 95 F0              4196 	subb	a,b
   139E 50 0C              4197 	jnc	00193$
                           4198 ;	setting.c:189: cZVal++;
   13A0 05*1C              4199 	inc	_SettingActivity_cZVal_1_184
                           4200 ;	setting.c:188: for( ni = 0; ni < date[1] % 10 ; ni++	)
   13A2 05*28              4201 	inc	_SettingActivity_ni_1_184
   13A4 E4                 4202 	clr	a
   13A5 B5*28 CC           4203 	cjne	a,_SettingActivity_ni_1_184,00190$
   13A8 05*29              4204 	inc	(_SettingActivity_ni_1_184 + 1)
   13AA 80 C8              4205 	sjmp	00190$
   13AC                    4206 00193$:
                           4207 ;	setting.c:191: cYVal <<=4;
   13AC EE                 4208 	mov	a,r6
   13AD C4                 4209 	swap	a
   13AE 54 F0              4210 	anl	a,#0xF0
   13B0 FE                 4211 	mov	r6,a
                           4212 ;	setting.c:192: cYVal &= 0xf0;
   13B1 53 06 F0           4213 	anl	ar6,#0xF0
                           4214 ;	setting.c:193: cZVal &=0x0f;
   13B4 74 0F              4215 	mov	a,#0x0F
   13B6 55*1C              4216 	anl	a,_SettingActivity_cZVal_1_184
                           4217 ;	setting.c:194: cYVal |= cZVal;			//Month stored in YVal;
   13B8 42 06              4218 	orl	ar6,a
                           4219 ;	setting.c:196: cZVal = 0x00;
                           4220 ;	setting.c:198: for( ni = 0; ni < date[2] / 10 ; ni++	)		//year...
   13BA E4                 4221 	clr	a
   13BB FD                 4222 	mov	r5,a
   13BC FC                 4223 	mov	r4,a
   13BD F5*28              4224 	mov	_SettingActivity_ni_1_184,a
   13BF F5*29              4225 	mov	(_SettingActivity_ni_1_184 + 1),a
   13C1                    4226 00194$:
   13C1 85*26 82           4227 	mov	dpl,(_SettingActivity_date_1_184 + 0x0004)
   13C4 85*27 83           4228 	mov	dph,((_SettingActivity_date_1_184 + 0x0004) + 1)
   13C7 75*00 0A           4229 	mov	__divsint_PARM_2,#0x0A
   13CA 75*01 00           4230 	mov	(__divsint_PARM_2 + 1),#0x00
   13CD C0 07              4231 	push	ar7
   13CF C0 06              4232 	push	ar6
   13D1 C0 04              4233 	push	ar4
   13D3 12s00r00           4234 	lcall	__divsint
   13D6 AA 82              4235 	mov	r2,dpl
   13D8 AB 83              4236 	mov	r3,dph
   13DA D0 04              4237 	pop	ar4
   13DC D0 06              4238 	pop	ar6
   13DE D0 07              4239 	pop	ar7
   13E0 C3                 4240 	clr	c
   13E1 E5*28              4241 	mov	a,_SettingActivity_ni_1_184
   13E3 9A                 4242 	subb	a,r2
   13E4 E5*29              4243 	mov	a,(_SettingActivity_ni_1_184 + 1)
   13E6 64 80              4244 	xrl	a,#0x80
   13E8 8B F0              4245 	mov	b,r3
   13EA 63 F0 80           4246 	xrl	b,#0x80
   13ED 95 F0              4247 	subb	a,b
   13EF 50 0D              4248 	jnc	00275$
                           4249 ;	setting.c:199: cZVal++;
   13F1 0C                 4250 	inc	r4
   13F2 8C 05              4251 	mov	ar5,r4
                           4252 ;	setting.c:198: for( ni = 0; ni < date[2] / 10 ; ni++	)		//year...
   13F4 05*28              4253 	inc	_SettingActivity_ni_1_184
   13F6 E4                 4254 	clr	a
   13F7 B5*28 C7           4255 	cjne	a,_SettingActivity_ni_1_184,00194$
   13FA 05*29              4256 	inc	(_SettingActivity_ni_1_184 + 1)
   13FC 80 C3              4257 	sjmp	00194$
   13FE                    4258 00275$:
   13FE 8C 05              4259 	mov	ar5,r4
                           4260 ;	setting.c:200: for( ni = 0; ni < date[2] % 10 ; ni++	)
   1400 E4                 4261 	clr	a
   1401 F5*1D              4262 	mov	_SettingActivity_cLVal_1_184,a
   1403 F5*28              4263 	mov	_SettingActivity_ni_1_184,a
   1405 F5*29              4264 	mov	(_SettingActivity_ni_1_184 + 1),a
   1407                    4265 00198$:
   1407 85*26 82           4266 	mov	dpl,(_SettingActivity_date_1_184 + 0x0004)
   140A 85*27 83           4267 	mov	dph,((_SettingActivity_date_1_184 + 0x0004) + 1)
   140D 75*00 0A           4268 	mov	__modsint_PARM_2,#0x0A
   1410 75*01 00           4269 	mov	(__modsint_PARM_2 + 1),#0x00
   1413 C0 07              4270 	push	ar7
   1415 C0 06              4271 	push	ar6
   1417 C0 05              4272 	push	ar5
   1419 12s00r00           4273 	lcall	__modsint
   141C AB 82              4274 	mov	r3,dpl
   141E AC 83              4275 	mov	r4,dph
   1420 D0 05              4276 	pop	ar5
   1422 D0 06              4277 	pop	ar6
   1424 D0 07              4278 	pop	ar7
   1426 C3                 4279 	clr	c
   1427 E5*28              4280 	mov	a,_SettingActivity_ni_1_184
   1429 9B                 4281 	subb	a,r3
   142A E5*29              4282 	mov	a,(_SettingActivity_ni_1_184 + 1)
   142C 64 80              4283 	xrl	a,#0x80
   142E 8C F0              4284 	mov	b,r4
   1430 63 F0 80           4285 	xrl	b,#0x80
   1433 95 F0              4286 	subb	a,b
   1435 50 0C              4287 	jnc	00201$
                           4288 ;	setting.c:201: cLVal++;	
   1437 05*1D              4289 	inc	_SettingActivity_cLVal_1_184
                           4290 ;	setting.c:200: for( ni = 0; ni < date[2] % 10 ; ni++	)
   1439 05*28              4291 	inc	_SettingActivity_ni_1_184
   143B E4                 4292 	clr	a
   143C B5*28 C8           4293 	cjne	a,_SettingActivity_ni_1_184,00198$
   143F 05*29              4294 	inc	(_SettingActivity_ni_1_184 + 1)
   1441 80 C4              4295 	sjmp	00198$
   1443                    4296 00201$:
                           4297 ;	setting.c:202: cZVal <<=4;
   1443 ED                 4298 	mov	a,r5
   1444 C4                 4299 	swap	a
   1445 54 F0              4300 	anl	a,#0xF0
   1447 FD                 4301 	mov	r5,a
                           4302 ;	setting.c:203: cZVal &= 0xf0;
   1448 53 05 F0           4303 	anl	ar5,#0xF0
                           4304 ;	setting.c:204: cLVal &=0x0f;
   144B 74 0F              4305 	mov	a,#0x0F
   144D 55*1D              4306 	anl	a,_SettingActivity_cLVal_1_184
                           4307 ;	setting.c:205: cZVal |= cLVal;			//Year stored in ZVal;	
   144F 4D                 4308 	orl	a,r5
   1450 F5*15              4309 	mov	_RTC_setdate_PARM_3,a
                           4310 ;	setting.c:207: RTC_setdate( cXVal, cYVal, cZVal );
   1452 8E*14              4311 	mov	_RTC_setdate_PARM_2,r6
   1454 8F 82              4312 	mov	dpl,r7
                           4313 ;	setting.c:211: return;
   1456 02s08r43           4314 	ljmp	_RTC_setdate
                           4315 ;------------------------------------------------------------
                           4316 ;Allocation info for local variables in function 'syncScreenActivity'
                           4317 ;------------------------------------------------------------
                           4318 ;cSyncChoice               Allocated to registers r6 
                           4319 ;BreakBit                  Allocated to registers r7 
                           4320 ;------------------------------------------------------------
                           4321 ;	syncScreen.c:16: void syncScreenActivity()							//routine for sync Operation...
                           4322 ;	-----------------------------------------
                           4323 ;	 function syncScreenActivity
                           4324 ;	-----------------------------------------
   1459                    4325 _syncScreenActivity:
                           4326 ;	syncScreen.c:19: clearLcdScreen();								//clear Output Screen...
   1459 12s02r68           4327 	lcall	_clearLcdScreen
                           4328 ;	syncScreen.c:23: setCursorLcd( 0, 5 );							//position the cursor
   145C 75*06 05           4329 	mov	_setCursorLcd_PARM_2,#0x05
   145F 75*07 00           4330 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   1462 90 00 00           4331 	mov	dptr,#0x0000
   1465 12s02r10           4332 	lcall	_setCursorLcd
                           4333 ;	syncScreen.c:24: displayStringLcd("Want to Sync?");
   1468 90s00rD7           4334 	mov	dptr,#__str_13
   146B 75 F0 80           4335 	mov	b,#0x80
   146E 12s01r6B           4336 	lcall	_displayStringLcd
                           4337 ;	syncScreen.c:25: setCursorLcd( 1, 5 );	
   1471 75*06 05           4338 	mov	_setCursorLcd_PARM_2,#0x05
   1474 75*07 00           4339 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   1477 90 00 01           4340 	mov	dptr,#0x0001
   147A 12s02r10           4341 	lcall	_setCursorLcd
                           4342 ;	syncScreen.c:26: displayCharLcd( 0xdb );
   147D 75 82 DB           4343 	mov	dpl,#0xDB
   1480 12s01r63           4344 	lcall	_displayCharLcd
                           4345 ;	syncScreen.c:27: displayStringLcd( "Yes" );
   1483 90s00rE5           4346 	mov	dptr,#__str_14
   1486 75 F0 80           4347 	mov	b,#0x80
   1489 12s01r6B           4348 	lcall	_displayStringLcd
                           4349 ;	syncScreen.c:28: setCursorLcd( 2, 5 );
   148C 75*06 05           4350 	mov	_setCursorLcd_PARM_2,#0x05
   148F 75*07 00           4351 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   1492 90 00 02           4352 	mov	dptr,#0x0002
   1495 12s02r10           4353 	lcall	_setCursorLcd
                           4354 ;	syncScreen.c:29: displayCharLcd( 0x7f );
   1498 75 82 7F           4355 	mov	dpl,#0x7F
   149B 12s01r63           4356 	lcall	_displayCharLcd
                           4357 ;	syncScreen.c:30: displayStringLcd("Cancel");
   149E 90s00rE9           4358 	mov	dptr,#__str_15
   14A1 75 F0 80           4359 	mov	b,#0x80
   14A4 12s01r6B           4360 	lcall	_displayStringLcd
                           4361 ;	syncScreen.c:33: BreakBit = 0x00;
   14A7 7F 00              4362 	mov	r7,#0x00
                           4363 ;	syncScreen.c:35: eepromWriteTo( 'A', 0x00);
   14A9 75*0A 00           4364 	mov	_eepromWriteTo_PARM_2,#0x00
   14AC 75 82 41           4365 	mov	dpl,#0x41
   14AF C0 07              4366 	push	ar7
   14B1 12s06r2B           4367 	lcall	_eepromWriteTo
                           4368 ;	syncScreen.c:36: key_init();
   14B4 12s00r63           4369 	lcall	_key_init
   14B7 D0 07              4370 	pop	ar7
                           4371 ;	syncScreen.c:38: while ( 1 )
   14B9                    4372 00107$:
                           4373 ;	syncScreen.c:40: cSyncChoice = translateKeyCode( get_key() );
   14B9 C0 07              4374 	push	ar7
   14BB 12s00r67           4375 	lcall	_get_key
   14BE 12s00rC7           4376 	lcall	_translateKeyCode
   14C1 AE 82              4377 	mov	r6,dpl
   14C3 D0 07              4378 	pop	ar7
                           4379 ;	syncScreen.c:42: switch( cSyncChoice )
   14C5 BE 33 02           4380 	cjne	r6,#0x33,00117$
   14C8 80 05              4381 	sjmp	00101$
   14CA                    4382 00117$:
                           4383 ;	syncScreen.c:44: case '3':
   14CA BE 37 33           4384 	cjne	r6,#0x37,00103$
   14CD 80 04              4385 	sjmp	00102$
   14CF                    4386 00101$:
                           4387 ;	syncScreen.c:45: BreakBit  = 0x01;
   14CF 7F 01              4388 	mov	r7,#0x01
                           4389 ;	syncScreen.c:46: break;
                           4390 ;	syncScreen.c:47: case '7':
   14D1 80 2D              4391 	sjmp	00103$
   14D3                    4392 00102$:
                           4393 ;	syncScreen.c:49: setCursorLcd( 3,  0);
   14D3 E4                 4394 	clr	a
   14D4 F5*06              4395 	mov	_setCursorLcd_PARM_2,a
   14D6 F5*07              4396 	mov	(_setCursorLcd_PARM_2 + 1),a
   14D8 90 00 03           4397 	mov	dptr,#0x0003
   14DB C0 07              4398 	push	ar7
   14DD 12s02r10           4399 	lcall	_setCursorLcd
                           4400 ;	syncScreen.c:50: displayStringLcd( "Syncing your Data..." );
   14E0 90s00rF0           4401 	mov	dptr,#__str_16
   14E3 75 F0 80           4402 	mov	b,#0x80
   14E6 12s01r6B           4403 	lcall	_displayStringLcd
                           4404 ;	syncScreen.c:53: setCursorLcd( 0, 0 );
   14E9 E4                 4405 	clr	a
   14EA F5*06              4406 	mov	_setCursorLcd_PARM_2,a
   14EC F5*07              4407 	mov	(_setCursorLcd_PARM_2 + 1),a
   14EE F5 82              4408 	mov	dpl,a
   14F0 F5 83              4409 	mov	dph,a
   14F2 12s02r10           4410 	lcall	_setCursorLcd
                           4411 ;	syncScreen.c:54: displayCharLcd (eepromReadFrom( 0));
   14F5 75 82 00           4412 	mov	dpl,#0x00
   14F8 12s06r5A           4413 	lcall	_eepromReadFrom
   14FB 12s01r63           4414 	lcall	_displayCharLcd
   14FE D0 07              4415 	pop	ar7
                           4416 ;	syncScreen.c:57: }
   1500                    4417 00103$:
                           4418 ;	syncScreen.c:58: if( BreakBit == 0x01 )
   1500 BF 01 B6           4419 	cjne	r7,#0x01,00107$
                           4420 ;	syncScreen.c:60: break;
   1503 22                 4421 	ret
                           4422 ;------------------------------------------------------------
                           4423 ;Allocation info for local variables in function 'dataEntrySession'
                           4424 ;------------------------------------------------------------
                           4425 ;cDataEntryChoice          Allocated to registers r6 
                           4426 ;BreakFlg                  Allocated to registers r7 
                           4427 ;------------------------------------------------------------
                           4428 ;	dataentry.c:16: void dataEntrySession()					//Session will be there, as routine for Data Entry...
                           4429 ;	-----------------------------------------
                           4430 ;	 function dataEntrySession
                           4431 ;	-----------------------------------------
   1504                    4432 _dataEntrySession:
                           4433 ;	dataentry.c:18: char cDataEntryChoice, BreakFlg = 0x00;
   1504 7F 00              4434 	mov	r7,#0x00
                           4435 ;	dataentry.c:19: clearLcdScreen();								//clear Output Screen...
   1506 C0 07              4436 	push	ar7
   1508 12s02r68           4437 	lcall	_clearLcdScreen
                           4438 ;	dataentry.c:22: setCursorLcd( 0, 5 );							//position the cursor
   150B 75*06 05           4439 	mov	_setCursorLcd_PARM_2,#0x05
   150E 75*07 00           4440 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   1511 90 00 00           4441 	mov	dptr,#0x0000
   1514 12s02r10           4442 	lcall	_setCursorLcd
                           4443 ;	dataentry.c:23: displayStringLcd("Data Entry");
   1517 90s01r05           4444 	mov	dptr,#__str_17
   151A 75 F0 80           4445 	mov	b,#0x80
   151D 12s01r6B           4446 	lcall	_displayStringLcd
                           4447 ;	dataentry.c:24: setCursorLcd( 1, 5 );	
   1520 75*06 05           4448 	mov	_setCursorLcd_PARM_2,#0x05
   1523 75*07 00           4449 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   1526 90 00 01           4450 	mov	dptr,#0x0001
   1529 12s02r10           4451 	lcall	_setCursorLcd
                           4452 ;	dataentry.c:25: displayCharLcd( 0xdb );
   152C 75 82 DB           4453 	mov	dpl,#0xDB
   152F 12s01r63           4454 	lcall	_displayCharLcd
                           4455 ;	dataentry.c:26: displayStringLcd( "Start?" );
   1532 90s01r10           4456 	mov	dptr,#__str_18
   1535 75 F0 80           4457 	mov	b,#0x80
   1538 12s01r6B           4458 	lcall	_displayStringLcd
                           4459 ;	dataentry.c:27: setCursorLcd( 2, 5 );
   153B 75*06 05           4460 	mov	_setCursorLcd_PARM_2,#0x05
   153E 75*07 00           4461 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   1541 90 00 02           4462 	mov	dptr,#0x0002
   1544 12s02r10           4463 	lcall	_setCursorLcd
                           4464 ;	dataentry.c:28: displayCharLcd( 0x7f );
   1547 75 82 7F           4465 	mov	dpl,#0x7F
   154A 12s01r63           4466 	lcall	_displayCharLcd
                           4467 ;	dataentry.c:29: displayStringLcd("Back?");
   154D 90s01r17           4468 	mov	dptr,#__str_19
   1550 75 F0 80           4469 	mov	b,#0x80
   1553 12s01r6B           4470 	lcall	_displayStringLcd
                           4471 ;	dataentry.c:31: key_init();
   1556 12s00r63           4472 	lcall	_key_init
   1559 D0 07              4473 	pop	ar7
                           4474 ;	dataentry.c:33: while ( 1 )
   155B                    4475 00107$:
                           4476 ;	dataentry.c:35: cDataEntryChoice = translateKeyCode( get_key() );
   155B C0 07              4477 	push	ar7
   155D 12s00r67           4478 	lcall	_get_key
   1560 12s00rC7           4479 	lcall	_translateKeyCode
   1563 AE 82              4480 	mov	r6,dpl
   1565 D0 07              4481 	pop	ar7
                           4482 ;	dataentry.c:37: switch( cDataEntryChoice )
   1567 BE 33 02           4483 	cjne	r6,#0x33,00117$
   156A 80 05              4484 	sjmp	00101$
   156C                    4485 00117$:
                           4486 ;	dataentry.c:39: case '3':
   156C BE 37 1D           4487 	cjne	r6,#0x37,00103$
   156F 80 04              4488 	sjmp	00102$
   1571                    4489 00101$:
                           4490 ;	dataentry.c:40: BreakFlg  = 0x01;
   1571 7F 01              4491 	mov	r7,#0x01
                           4492 ;	dataentry.c:41: break;
                           4493 ;	dataentry.c:42: case '7':
   1573 80 17              4494 	sjmp	00103$
   1575                    4495 00102$:
                           4496 ;	dataentry.c:43: setCursorLcd( 3, 5 );
   1575 75*06 05           4497 	mov	_setCursorLcd_PARM_2,#0x05
   1578 75*07 00           4498 	mov	(_setCursorLcd_PARM_2 + 1),#0x00
   157B 90 00 03           4499 	mov	dptr,#0x0003
   157E 12s02r10           4500 	lcall	_setCursorLcd
                           4501 ;	dataentry.c:44: displayStringLcd( "Data entry Started...");		
   1581 90s01r1D           4502 	mov	dptr,#__str_20
   1584 75 F0 80           4503 	mov	b,#0x80
   1587 12s01r6B           4504 	lcall	_displayStringLcd
                           4505 ;	dataentry.c:45: BreakFlg = 0x01;
   158A 7F 01              4506 	mov	r7,#0x01
                           4507 ;	dataentry.c:47: }
   158C                    4508 00103$:
                           4509 ;	dataentry.c:48: if( BreakFlg == 0x01 )
   158C BF 01 CC           4510 	cjne	r7,#0x01,00107$
                           4511 ;	dataentry.c:49: break;
   158F 22                 4512 	ret
                           4513 ;------------------------------------------------------------
                           4514 ;Allocation info for local variables in function 'main'
                           4515 ;------------------------------------------------------------
                           4516 ;cChoiceMenu               Allocated to registers r7 
                           4517 ;------------------------------------------------------------
                           4518 ;	main.c:17: void main(){
                           4519 ;	-----------------------------------------
                           4520 ;	 function main
                           4521 ;	-----------------------------------------
   1590                    4522 _main:
                           4523 ;	main.c:19: lcdBegin();
   1590 12s00rEB           4524 	lcall	_lcdBegin
                           4525 ;	main.c:20: SplashScreenWindow();
   1593 12s03rA3           4526 	lcall	_SplashScreenWindow
                           4527 ;	main.c:21: InitUartComm();
   1596 12s00r42           4528 	lcall	_InitUartComm
                           4529 ;	main.c:22: delay( 1000 );
   1599 90 03 E8           4530 	mov	dptr,#0x03E8
   159C 12s00r00           4531 	lcall	_delay
                           4532 ;	main.c:23: key_init();
   159F 12s00r63           4533 	lcall	_key_init
                           4534 ;	main.c:24: ecs_MainMenu();	
   15A2 12s0Dr4F           4535 	lcall	_ecs_MainMenu
                           4536 ;	main.c:25: while( 1 )
   15A5                    4537 00110$:
                           4538 ;	main.c:28: cChoiceMenu = translateKeyCode( get_key() );
   15A5 12s00r67           4539 	lcall	_get_key
   15A8 12s00rC7           4540 	lcall	_translateKeyCode
   15AB AF 82              4541 	mov	r7,dpl
                           4542 ;	main.c:30: if( cChoiceMenu == '3' ){
   15AD BF 33 0B           4543 	cjne	r7,#0x33,00107$
                           4544 ;	main.c:32: syncScreenActivity();
   15B0 12s14r59           4545 	lcall	_syncScreenActivity
                           4546 ;	main.c:33: clearLcdScreen();
   15B3 12s02r68           4547 	lcall	_clearLcdScreen
                           4548 ;	main.c:34: ecs_MainMenu();
   15B6 12s0Dr4F           4549 	lcall	_ecs_MainMenu
   15B9 80 EA              4550 	sjmp	00110$
   15BB                    4551 00107$:
                           4552 ;	main.c:36: else if( cChoiceMenu == '7' )
   15BB BF 37 0B           4553 	cjne	r7,#0x37,00104$
                           4554 ;	main.c:39: SettingActivity();
   15BE 12s0Er35           4555 	lcall	_SettingActivity
                           4556 ;	main.c:40: clearLcdScreen();
   15C1 12s02r68           4557 	lcall	_clearLcdScreen
                           4558 ;	main.c:41: ecs_MainMenu();
   15C4 12s0Dr4F           4559 	lcall	_ecs_MainMenu
   15C7 80 DC              4560 	sjmp	00110$
   15C9                    4561 00104$:
                           4562 ;	main.c:43: else if( cChoiceMenu == 'B')
   15C9 BF 42 D9           4563 	cjne	r7,#0x42,00110$
                           4564 ;	main.c:46: dataEntrySession();
   15CC 12s15r04           4565 	lcall	_dataEntrySession
                           4566 ;	main.c:47: clearLcdScreen();
   15CF 12s02r68           4567 	lcall	_clearLcdScreen
                           4568 ;	main.c:48: ecs_MainMenu();
   15D2 12s0Dr4F           4569 	lcall	_ecs_MainMenu
   15D5 80 CE              4570 	sjmp	00110$
                           4571 	.area CSEG    (CODE)
                           4572 	.area CONST   (CODE)
   0000                    4573 _cgram_Character_Slot:
   0000 1F                 4574 	.db #0x1F	;  31
   0001 10                 4575 	.db #0x10	;  16
   0002 10                 4576 	.db #0x10	;  16
   0003 10                 4577 	.db #0x10	;  16
   0004 10                 4578 	.db #0x10	;  16
   0005 10                 4579 	.db #0x10	;  16
   0006 10                 4580 	.db #0x10	;  16
   0007 10                 4581 	.db #0x10	;  16
   0008 1F                 4582 	.db #0x1F	;  31
   0009 00                 4583 	.db #0x00	;  0
   000A 00                 4584 	.db #0x00	;  0
   000B 00                 4585 	.db #0x00	;  0
   000C 00                 4586 	.db #0x00	;  0
   000D 00                 4587 	.db #0x00	;  0
   000E 00                 4588 	.db #0x00	;  0
   000F 00                 4589 	.db #0x00	;  0
   0010 1F                 4590 	.db #0x1F	;  31
   0011 01                 4591 	.db #0x01	;  1
   0012 01                 4592 	.db #0x01	;  1
   0013 01                 4593 	.db #0x01	;  1
   0014 01                 4594 	.db #0x01	;  1
   0015 01                 4595 	.db #0x01	;  1
   0016 01                 4596 	.db #0x01	;  1
   0017 01                 4597 	.db #0x01	;  1
   0018 10                 4598 	.db #0x10	;  16
   0019 10                 4599 	.db #0x10	;  16
   001A 10                 4600 	.db #0x10	;  16
   001B 10                 4601 	.db #0x10	;  16
   001C 10                 4602 	.db #0x10	;  16
   001D 10                 4603 	.db #0x10	;  16
   001E 10                 4604 	.db #0x10	;  16
   001F 10                 4605 	.db #0x10	;  16
   0020 01                 4606 	.db #0x01	;  1
   0021 01                 4607 	.db #0x01	;  1
   0022 01                 4608 	.db #0x01	;  1
   0023 01                 4609 	.db #0x01	;  1
   0024 01                 4610 	.db #0x01	;  1
   0025 01                 4611 	.db #0x01	;  1
   0026 01                 4612 	.db #0x01	;  1
   0027 01                 4613 	.db #0x01	;  1
   0028 10                 4614 	.db #0x10	;  16
   0029 10                 4615 	.db #0x10	;  16
   002A 10                 4616 	.db #0x10	;  16
   002B 10                 4617 	.db #0x10	;  16
   002C 10                 4618 	.db #0x10	;  16
   002D 10                 4619 	.db #0x10	;  16
   002E 10                 4620 	.db #0x10	;  16
   002F 1F                 4621 	.db #0x1F	;  31
   0030 01                 4622 	.db #0x01	;  1
   0031 01                 4623 	.db #0x01	;  1
   0032 01                 4624 	.db #0x01	;  1
   0033 01                 4625 	.db #0x01	;  1
   0034 01                 4626 	.db #0x01	;  1
   0035 01                 4627 	.db #0x01	;  1
   0036 01                 4628 	.db #0x01	;  1
   0037 1F                 4629 	.db #0x1F	;  31
   0038 00                 4630 	.db #0x00	;  0
   0039 00                 4631 	.db #0x00	;  0
   003A 00                 4632 	.db #0x00	;  0
   003B 00                 4633 	.db #0x00	;  0
   003C 00                 4634 	.db #0x00	;  0
   003D 00                 4635 	.db #0x00	;  0
   003E 00                 4636 	.db #0x00	;  0
   003F 1F                 4637 	.db #0x1F	;  31
   0040                    4638 __str_0:
   0040 45 43 53           4639 	.ascii "ECS"
   0043 00                 4640 	.db 0x00
   0044                    4641 __str_1:
   0044 45 6C 69 74 65 20  4642 	.ascii "Elite Cab Suite"
        43 61 62 20 53 75
        69 74 65
   0053 00                 4643 	.db 0x00
   0054                    4644 __str_2:
   0054 4D 61 69 6E        4645 	.ascii "Main"
   0058 00                 4646 	.db 0x00
   0059                    4647 __str_3:
   0059 4D 65 6E 75        4648 	.ascii "Menu"
   005D 00                 4649 	.db 0x00
   005E                    4650 __str_4:
   005E 53 79 6E 63 20 44  4651 	.ascii "Sync Data..."
        61 74 61 2E 2E 2E
   006A 00                 4652 	.db 0x00
   006B                    4653 __str_5:
   006B 53 65 74 74 69 6E  4654 	.ascii "Settings..."
        67 73 2E 2E 2E
   0076 00                 4655 	.db 0x00
   0077                    4656 __str_6:
   0077 44 61 74 61 20 45  4657 	.ascii "Data Entry..."
        6E 74 72 79 2E 2E
        2E
   0084 00                 4658 	.db 0x00
   0085                    4659 __str_7:
   0085 53 65 74 20 44 61  4660 	.ascii "Set Date & Time"
        74 65 20 26 20 54
        69 6D 65
   0094 00                 4661 	.db 0x00
   0095                    4662 __str_8:
   0095 45 6E 74 65 72 20  4663 	.ascii "Enter Minute:"
        4D 69 6E 75 74 65
        3A
   00A2 00                 4664 	.db 0x00
   00A3                    4665 __str_9:
   00A3 45 6E 74 65 72 20  4666 	.ascii "Enter Hours:"
        48 6F 75 72 73 3A
   00AF 00                 4667 	.db 0x00
   00B0                    4668 __str_10:
   00B0 45 6E 74 65 72 20  4669 	.ascii "Enter Date"
        44 61 74 65
   00BA 00                 4670 	.db 0x00
   00BB                    4671 __str_11:
   00BB 45 6E 74 65 72 20  4672 	.ascii "Enter Month"
        4D 6F 6E 74 68
   00C6 00                 4673 	.db 0x00
   00C7                    4674 __str_12:
   00C7 45 6E 74 65 72 20  4675 	.ascii "Enter Year:20xx"
        59 65 61 72 3A 32
        30 78 78
   00D6 00                 4676 	.db 0x00
   00D7                    4677 __str_13:
   00D7 57 61 6E 74 20 74  4678 	.ascii "Want to Sync?"
        6F 20 53 79 6E 63
        3F
   00E4 00                 4679 	.db 0x00
   00E5                    4680 __str_14:
   00E5 59 65 73           4681 	.ascii "Yes"
   00E8 00                 4682 	.db 0x00
   00E9                    4683 __str_15:
   00E9 43 61 6E 63 65 6C  4684 	.ascii "Cancel"
   00EF 00                 4685 	.db 0x00
   00F0                    4686 __str_16:
   00F0 53 79 6E 63 69 6E  4687 	.ascii "Syncing your Data..."
        67 20 79 6F 75 72
        20 44 61 74 61 2E
        2E 2E
   0104 00                 4688 	.db 0x00
   0105                    4689 __str_17:
   0105 44 61 74 61 20 45  4690 	.ascii "Data Entry"
        6E 74 72 79
   010F 00                 4691 	.db 0x00
   0110                    4692 __str_18:
   0110 53 74 61 72 74 3F  4693 	.ascii "Start?"
   0116 00                 4694 	.db 0x00
   0117                    4695 __str_19:
   0117 42 61 63 6B 3F     4696 	.ascii "Back?"
   011C 00                 4697 	.db 0x00
   011D                    4698 __str_20:
   011D 44 61 74 61 20 65  4699 	.ascii "Data entry Started..."
        6E 74 72 79 20 53
        74 61 72 74 65 64
        2E 2E 2E
   0132 00                 4700 	.db 0x00
                           4701 	.area XINIT   (CODE)
                           4702 	.area CABS    (ABS,CODE)
